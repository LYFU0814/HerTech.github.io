<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lyfu0814.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="语言特点语言性质 面向对象编程（OOP）：允许用户定义类和对象，以及类的成员函数和数据成员。OOP的主要特性包括封装、继承和多态。  封装是一种将数据和操作数据的函数组合在一起的方法，这样可以隐藏对象的内部细节。封装可以提高代码的可读性和可维护性。 继承是一种允许从现有类派生出新类的方法，新类可以继承现有类的属性和方法，还可以添加新的属性和方法或者覆盖现有的方法。 多态是一种允许在程序中使用通">
<meta property="og:type" content="article">
<meta property="og:title" content="基本语言">
<meta property="og:url" content="https://lyfu0814.github.io/2023/11/08/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="HerTech">
<meta property="og:description" content="语言特点语言性质 面向对象编程（OOP）：允许用户定义类和对象，以及类的成员函数和数据成员。OOP的主要特性包括封装、继承和多态。  封装是一种将数据和操作数据的函数组合在一起的方法，这样可以隐藏对象的内部细节。封装可以提高代码的可读性和可维护性。 继承是一种允许从现有类派生出新类的方法，新类可以继承现有类的属性和方法，还可以添加新的属性和方法或者覆盖现有的方法。 多态是一种允许在程序中使用通">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-08T03:08:20.000Z">
<meta property="article:modified_time" content="2023-11-08T03:29:17.929Z">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lyfu0814.github.io/2023/11/08/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E8%A8%80/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lyfu0814.github.io/2023/11/08/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E8%A8%80/","path":"2023/11/08/基本语言/","title":"基本语言"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>基本语言 | HerTech</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="HerTech" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">HerTech</p>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/uploads/logo.jpg" alt="HerTech">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">语言特点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E6%80%A7%E8%B4%A8"><span class="nav-number">1.1.</span> <span class="nav-text">语言性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">1.2.</span> <span class="nav-text">组成部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E9%AB%98C-%E6%80%A7%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">提高C++性的方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="nav-number">2.1.</span> <span class="nav-text">定义和声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.</span> <span class="nav-text">全局变量和局部变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#extern%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.3.</span> <span class="nav-text">extern关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#explicit%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.4.</span> <span class="nav-text">explicit关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.5.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98"><span class="nav-number">2.6.</span> <span class="nav-text">静态成员和普通成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.7.</span> <span class="nav-text">volatile关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mutable%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.8.</span> <span class="nav-text">mutable关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="nav-number">2.9.</span> <span class="nav-text">左值和右值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#typedef-%E5%A3%B0%E6%98%8E"><span class="nav-number">2.10.</span> <span class="nav-text">typedef 声明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-number">3.1.</span> <span class="nav-text">const限定符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class%E3%80%81union%E3%80%81struct"><span class="nav-number">4.</span> <span class="nav-text">class、union、struct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.</span> <span class="nav-text">数据类型和类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="nav-number">5.1.</span> <span class="nav-text">怎样判断两个浮点数是否相等</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.2.</span> <span class="nav-text">隐式转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.3.</span> <span class="nav-text">四种显示转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#auto%E5%92%8Cdecltype%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-number">5.4.</span> <span class="nav-text">auto和decltype类型说明符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#null%E4%B8%8Enullptr%E5%8C%BA%E5%88%AB"><span class="nav-number">5.5.</span> <span class="nav-text">null与nullptr区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">指针和引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">6.1.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">6.2.</span> <span class="nav-text">左值引用和右值引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">6.3.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.4.</span> <span class="nav-text">引用和指针的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.5.</span> <span class="nav-text">指针和引用之间如何转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">6.6.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">6.7.</span> <span class="nav-text">智能指针内存泄漏问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.8.</span> <span class="nav-text">指针和数组的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E6%8C%82%E6%8C%87%E9%92%88"><span class="nav-number">6.9.</span> <span class="nav-text">野指针和悬挂指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">6.10.</span> <span class="nav-text">函数指针</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="nav-number">7.1.</span> <span class="nav-text">函数的定义和声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">7.2.</span> <span class="nav-text">参数传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.</span> <span class="nav-text">返回类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.</span> <span class="nav-text">内联函数和constexpr函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="nav-number">7.5.</span> <span class="nav-text">函数匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%85%88%E4%BA%8Emain%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C"><span class="nav-number">7.6.</span> <span class="nav-text">实现一个函数先于main函数运行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number"></span> <span class="nav-text">标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IO%E7%B1%BB"><span class="nav-number">0.1.</span> <span class="nav-text">IO类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">0.2.</span> <span class="nav-text">顺序容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-number">0.3.</span> <span class="nav-text">关联容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-number">0.4.</span> <span class="nav-text">泛型算法</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">uu的博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_42659457" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42659457" rel="noopener me" target="_blank"><i class="csdn fa-fw"></i>CSDN</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lyfu0814.github.io/2023/11/08/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HerTech">
      <meta itemprop="description" content="uu的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="基本语言 | HerTech">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基本语言
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-08 11:08:20 / 修改时间：11:29:17" itemprop="dateCreated datePublished" datetime="2023-11-08T11:08:20+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">C++总结</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><span id="more"></span>

<h4 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h4><h5 id="语言性质"><a href="#语言性质" class="headerlink" title="语言性质"></a>语言性质</h5><ul>
<li><p><strong>面向对象编程（OOP）</strong>：允许用户定义类和对象，以及类的成员函数和数据成员。OOP的主要特性包括封装、继承和多态。</p>
<ul>
<li><strong>封装</strong>是一种将数据和操作数据的函数组合在一起的方法，这样可以隐藏对象的内部细节。封装可以提高代码的可读性和可维护性。</li>
<li><strong>继承</strong>是一种允许从现有类派生出新类的方法，新类可以继承现有类的属性和方法，还可以添加新的属性和方法或者覆盖现有的方法。</li>
<li><strong>多态</strong>是一种允许在程序中使用通用接口来处理不同类型的对象的方法。多态可以简化代码，提高代码的可扩展性和复用性。</li>
</ul>
</li>
<li><p><strong>泛型编程</strong>：C++支持模板，允许用户编写通用的代码，以处理不同类型的数据。模板可以用于创建通用的函数和类，从而实现类型无关的编程。</p>
</li>
<li><p><strong>低级访问能力</strong>：C++允许用户直接操作内存和硬件，这使得C++成为一种高效且功能强大的语言，适用于底层编程和性能关键应用。</p>
</li>
<li><p><strong>标准库</strong>：C++有一个丰富的标准库，提供了许多常用功能和数据结构，如容器、算法、输入&#x2F;输出操作、字符串处理等。</p>
</li>
<li><p><strong>语言兼容性</strong>：C++与C语言具有很高的兼容性，这意味着大多数C程序可以在C++编译器中编译和运行。这使得C++可以轻松地与C语言代码集成。</p>
</li>
<li><p><strong>RAII（资源获取即初始化，Resource Acquisition Is Initialization）</strong>：RAII是一种在C++中广泛使用的编程技巧，它将资源的分配和释放与对象的生命周期关联起来。这有助于防止资源泄漏和简化资源管理。</p>
<ul>
<li>可以使用智能指针实现RAII</li>
</ul>
</li>
</ul>
<h5 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h5><ul>
<li>核心语言、C++标准库、标准模板库（STL）。</li>
</ul>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><ul>
<li>异常处理是通过一组特定的关键字和语法进行的。异常处理的主要目的是在程序运行过程中发生错误时提供一种优雅的处理和恢复机制。</li>
<li>C++通过使用try-catch块和标准异常类，可以确保程序在遇到问题时能够正常运行并提供有关错误的信息。<ul>
<li><strong>抛出异常（throw）</strong>：当检测到错误或异常情况时，可以使用throw关键字抛出一个异常。这可以是任何数据类型，比如整数、字符串或自定义类对象。</li>
<li><strong>捕获异常（catch）</strong>：为了捕获和处理异常，需要使用try和catch块。try块包含可能引发异常的代码。catch块用于捕获异常并处理它。</li>
<li><strong>标准异常类</strong>：C++标准库包含了一组异常类，这些类都继承自<code>std::exception</code>。一些常见的标准异常类包括<code>std::runtime_error</code>、<code>std::invalid_argument</code>、<code>std::out_of_range</code>等。</li>
<li><strong>自定义异常类</strong>：如果需要创建自定义异常类型，可以通过继承<code>std::exception</code>或其子类来实现。</li>
<li><strong>异常传播</strong>：当一个函数抛出一个异常，而该函数本身没有处理这个异常时，异常会向上传播至调用链上的上一级函数。如果没有任何函数捕获该异常，程序将终止并显示未捕获异常的错误信息。</li>
</ul>
</li>
</ul>
<h5 id="提高C-性的方式"><a href="#提高C-性的方式" class="headerlink" title="提高C++性的方式"></a>提高C++性的方式</h5><ul>
<li><strong>优化编译选项</strong>：使用编译器的优化选项，如 -O2 或 -O3，可以对生成的可执行文件进行优化。这些优化选项可能包括内联函数、循环展开、常量传播等。</li>
<li><strong>选择合适的数据结构和算法</strong>：根据问题选择合适的数据结构和算法。合理使用STL容器和算法，如 vector、map、sort等。这可以显著提高程序效率。</li>
<li><strong>避免不必要的内存分配</strong>：减少动态内存分配和释放的次数，使用对象池、预先分配内存、栈上分配内存等策略来减少内存碎片和提高性能。</li>
<li><strong>利用缓存</strong>：尽量让数据局部性更强，减少缓存未命中。对于计算量大的操作，可以使用缓存技术来存储结果，避免重复计算。</li>
<li><strong>并行计算</strong>：利用多核处理器、多线程、SIMD指令等并行计算技术，提高计算效率。使用C++11及更高版本的线程库、async、future等功能来实现多线程编程。</li>
<li><strong>避免使用异常处理作为正常控制流</strong>：异常处理对性能有一定影响，应仅在真正需要时使用。尽量使用错误码或其他方法作为正常控制流。</li>
<li><strong>使用内联函数和常量表达式</strong>：将小型函数声明为内联函数，以减少函数调用开销。使用constexpr关键字声明常量表达式，将在编译时计算值。</li>
<li><strong>使用智能指针管理资源</strong>：避免内存泄漏，采用 RAII(Resource Acquisition Is Initialization) 技术，使用智能指针如 shared_ptr、unique_ptr 管理动态分配的资源。</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="定义和声明"><a href="#定义和声明" class="headerlink" title="定义和声明"></a>定义和声明</h5><ul>
<li><strong>变量声明</strong>： 变量声明向编译器表明了变量的类型和名称，<strong>但不分配内存</strong>。声明的目的是在编译时告诉编译器变量的存在，以便在其他地方使用它。变量可以在程序中声明多次，但只能定义一次。</li>
<li><strong>变量定义</strong>： 变量定义既声明了变量，又为它分配了内存空间。定义同时还可以为变量指定初始值。变量在程序中只能定义一次，否则会导致编译错误。</li>
</ul>
<h5 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h5><ul>
<li><strong>全局变量</strong><ul>
<li>全局变量是在函数外部声明的变量，通常位于源文件的顶部。</li>
<li>全局变量在整个程序运行期间都是有效的，它们的作用范围是从声明处开始，直到程序结束。</li>
<li>全局变量可以在整个程序的任何地方访问，包括所有的函数和类。</li>
<li>全局变量在声明时具有默认初始值。例如，整数类型的全局变量默认初始化为0。</li>
<li>过多地使用全局变量可能导致代码的可维护性和可读性降低，因为它们可能在任何地方被访问和修改。因此，应谨慎使用全局变量。</li>
</ul>
</li>
<li><strong>局部变量</strong><ul>
<li>局部变量是在函数或代码块内声明的变量。</li>
<li>局部变量仅在声明它们的函数或代码块内部有效，离开这个范围后，它们就会被销毁。局部变量的作用范围仅限于声明它们的函数或代码块。</li>
<li>局部变量在声明时没有默认初始值，必须在使用之前对它们进行初始化。</li>
<li>局部变量有助于代码的封装和模块化，通常是编写可维护和可读代码的推荐方法。</li>
</ul>
</li>
</ul>
<h5 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h5><ul>
<li>用于声明全局变量或函数，表明它们的定义在其他地方（通常是另一个源文件）。这使得多个源文件可以共享同一个变量或函数，从而实现跨文件的代码组织和复用。</li>
</ul>
<h5 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h5><ul>
<li>explicit关键字用于修饰类的构造函数，以防止在某些情况下发生不希望的隐式类型转换。</li>
<li>默认情况下，如果一个构造函数只有一个参数，C++允许将该构造函数用于隐式类型转换。这可能导致意外的结果或难以发现的错误，使用<code>explicit</code>关键字可以禁止这种隐式类型转换，从而避免相关问题。</li>
</ul>
<h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><ul>
<li><p>主要用途：</p>
<ul>
<li><strong>隐藏</strong>：当<code>static</code>用于<strong>全局变量或函数</strong>时，它改变了变量或函数的可见性。静态的全局变量或函数仅在定义它们的源文件中可见，<strong>不会在其他源文件中产生冲突</strong>。</li>
<li><strong>保持变量持久且唯一</strong>：当<code>static</code>用于局部变量时，它将变量的生命周期延长到整个程序执行期间。</li>
<li><strong>静态类成员变量</strong>：当<code>static</code>用于类成员变量时，该成员变量被所有该类的对象共享，而不是为每个实例分配独立的存储空间。</li>
<li><strong>静态类成员函数</strong>：当<code>static</code>用于类成员函数时，这个函数可以在不创建类的实例的情况下直接通过类名调用。<strong>静态成员函数没有<code>this</code>指针，因此它只能访问类的静态成员变量。</strong></li>
</ul>
</li>
<li><p>静态变量的初始化时机c与c++不同：</p>
<ul>
<li>静态变量只会初始化一次，静态变量放在全局区域，所以在主程序之前就会为其分配内存。</li>
<li>对于c而言，c是在代码执行前，编译阶段分配好内存后，进行初始化。</li>
<li>对于c++而言，它是在执行相关代码时被初始化。</li>
</ul>
</li>
<li><p>修饰全局或局部变量：<strong>静态变量</strong></p>
<ul>
<li><p>C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象<strong>首次用到时进行构造</strong>。</p>
</li>
<li><p>全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
</li>
<li><p>局部静态变量作用域仍为局部作用域，当定义它的函数或者语句块结束时，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。</p>
</li>
</ul>
</li>
<li><p>修饰普通函数：<strong>静态函数</strong></p>
<ul>
<li>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</li>
</ul>
</li>
<li><p>修饰类的成员：<strong>类的静态成员和静态成员函数</strong>  </p>
<ul>
<li>静态成员：是类的所有对象中<strong>共享</strong>的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。  </li>
<li>对象与对象之间的成员变量是相互独立的。要想共用数据，则需要使用静态成员和静态方法。</li>
<li>既可以通过<strong>类名</strong>来对静态成员变量进行引用，也可以通过<strong>对象名</strong>来对静态成员变量进行引用。因为只要在类中声明静态成员变量，即使不定义对象，也可以为静态成员变量分配空间，进而可以使用静态成员变量。</li>
<li>静态成员变量是<strong>在程序编译时分配空间</strong>，而在程序结束时释放空间。  </li>
<li>初始化静态成员变量要在类的外面进行；</li>
</ul>
</li>
</ul>
<h5 id="静态成员和普通成员"><a href="#静态成员和普通成员" class="headerlink" title="静态成员和普通成员"></a>静态成员和普通成员</h5><ul>
<li><p><strong>存储和生命周期</strong></p>
<ul>
<li><p>静态成员：静态成员变量在类的所有实例之间共享，因此只有一个存储空间分配给静态成员变量。静态成员变量的生命周期从程序开始执行时就开始，一直持续到程序结束。</p>
</li>
<li><p>普通成员：每个类的实例都有自己的一份普通成员变量。这意味着每创建一个类的实例，都会为其普通成员变量分配独立的存储空间。普通成员变量的生命周期与其所属的类实例相同。随类实例的销毁而销毁。</p>
</li>
</ul>
</li>
<li><p><strong>访问方式</strong></p>
<ul>
<li><p>静态成员：静态成员变量和静态成员函数可以通过类名直接访问，而不需要创建类的实例。同时，静态成员函数也可以通过类的实例访问，但它们<strong>没有<code>this</code>指针，因此无法访问非静态成员变量。</strong></p>
</li>
<li><p>普通成员：普通成员变量和普通成员函数只能通过类的实例访问。它们可以访问类的所有成员（包括静态成员和非静态成员）。</p>
</li>
</ul>
</li>
<li><p><strong>初始化</strong></p>
<ul>
<li><p>静态成员：静态成员变量在程序启动之前的静态初始化阶段进行初始化。如果它们有显式的初始化器，则使用这些初始化器进行初始化；否则，它们将被初始化为零（整数类型）或者空（指针类型）。</p>
</li>
<li><p>普通成员：普通成员变量在创建类的实例时进行初始化。可以在构造函数中或使用成员初始化列表来初始化普通成员变量。</p>
</li>
</ul>
</li>
</ul>
<h5 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h5><ul>
<li><strong>防止编译器优化</strong>：编译器可能会对访问和修改变量的操作进行优化，例如将变量缓存在寄存器中或者删除对变量的多余访问。然而，这种优化可能导致程序行为不正确。volatile关键字确保编译器不会对这些变量进行不安全的优化，从而保持正确的程序行为。</li>
<li><strong>内存访问顺序</strong>：volatile关键字可以确保对修饰的变量的访问按照程序代码的顺序执行。这在多线程环境或硬件访问中很重要，因为它们通常依赖于严格的顺序执行。</li>
</ul>
<h5 id="mutable关键字"><a href="#mutable关键字" class="headerlink" title="mutable关键字"></a>mutable关键字</h5><ul>
<li><p>如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span> <span class="type">const</span>  <span class="comment">//在函数里不可修改this指针指向的值</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中</p>
</li>
</ul>
<h5 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h5><ul>
<li>左值和右值是表达式的属性<ul>
<li><strong>左值（lvalue）：</strong>在内存中<strong>占有确定位置</strong>的对象，有名字，可以取地址，可以出现在赋值号的左边或右边，当对象被用作左值时，用的是对象的身份（内存中的位置）。</li>
<li><strong>右值（rvalue）：</strong>不在内存中占有确定位置的表达式，不能对其进行赋值，可以出现在赋值号的右边，但不能出现在赋值号的左边，当对象被用作右值时，用的是对象的值。</li>
</ul>
</li>
<li><strong>左值持久而右值短暂</strong>：右值要么是字面常量，要么是在表达式求值过程中创建的临时对象；</li>
<li>需要右值的地方可以用左值替代，反之则不行。</li>
<li>几种常见用到左值的运算符：<ul>
<li>赋值运算符需要一个左值作为其左侧运算对象，得到的结果也是一个左值；</li>
<li>取地址符**&amp;**作用于一个左值对象，返回一个指向该运算对象的指针，这个指针是一个右值；</li>
<li>解引用符***<strong>、下标运算符</strong>[ ]**的求值结果都是左值；</li>
<li>内置类型和迭代器的递增递减运算符作用于左值对象，其前置版本所得的结果也是左值。</li>
</ul>
</li>
</ul>
<h5 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h5><ul>
<li>可以使用 <strong>typedef</strong> 关键字为一个已有的类型取一个新的名字。</li>
</ul>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ul>
<li>对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局&#x2F;静态存储区。对于字面值常量，常量存放在常量存储区。</li>
</ul>
<h5 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h5><ul>
<li><p><code>const</code>关键字用于表示常量性（constness），即某个对象或值在其生命周期内不能被修改。使用<code>const</code>关键字可以提高代码的可读性和安全性，因为它清楚地表明了哪些对象是不可变的，从而帮助我们避免意外地修改了不应该被修改的数据。</p>
<ul>
<li><strong>const对象必须初始化</strong>，一旦被初始化，其值就不能被修改。</li>
<li>默认状态下，const对象仅在文件内有效，如果想在文件间共享const对象，必须在变量的定义前添加extern关键字。</li>
</ul>
</li>
<li><p><strong>指针和引用</strong>：用于限制指针或引用所指向的对象的常量性。</p>
<ul>
<li><p><strong>const先修饰左边，左边没有就修饰右边</strong>。</p>
</li>
<li><p>const指针（<code>* const</code>）</p>
<ul>
<li><p>把指针本身定为常量，<strong>常量指针</strong>（const pointer）必须初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> m = &amp;x <span class="comment">//此时m是一个常量指针</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">24</span>;</span><br><span class="line">m = &amp;a; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常量指针不能指向其他地址，但是指针所指向地址上保存的变量可以修改</p>
</li>
</ul>
</li>
<li><p>指向常量的指针（<code>const *</code>）</p>
<ul>
<li><p>要想存放常量对象的地址，只能使用<strong>指向常量的指针</strong>（pointer to const）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;x; <span class="comment">// 声明一个指向常量整数的指针</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* q = &amp;x; <span class="comment">// 同上，声明一个指向常量整数的指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指向常量的指针不能用于改变其所指对象的值，但该对象是否能改变依赖于所指对象的类型</p>
</li>
<li><p>指向常量的指针可以指向一个非常量对象</p>
</li>
</ul>
</li>
<li><p>const的引用</p>
<ul>
<li><p>可以把引用绑定到const对象上，称之为<strong>对常量的引用</strong>（reference to const）；</p>
</li>
<li><p><strong>非常量引用不能绑定到常量对象上</strong>。</p>
</li>
<li><p>允许为一个常量引用绑定非常量的对象、字面值、甚至是一般表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r = x; <span class="comment">// 声明一个指向常量整数的引用</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>成员函数：在类成员函数中，使用const关键字表示该成员函数不会修改类的任何非静态成员变量（除非它们被声明为mutable）</p>
</li>
</ul>
</li>
<li><p><strong>顶层const和底层const</strong></p>
<ul>
<li><p><strong>顶层const表示对象本身是const，底层const表示指针所指的对象是const</strong>；</p>
</li>
<li><p>对一般对象，只有顶层const</p>
</li>
<li><p>对指针这种，本身是一个对象，又指向一个对象，故用顶层const表示指针是const，用底层const表示存放的地址为const（即指向的对象为const）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi;   <span class="comment">// pip 是一个指向常量对象的常量指针</span></span><br><span class="line"><span class="comment">// 第一个const：表明指针存放的地址为常量，即底层const，不能通过该指针修改所指对象的值；</span></span><br><span class="line"><span class="comment">// 第二个const：表明指针为常量对象，即pip不能指向其他对象                     </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对声明引用的const，都是底层const</strong>，因为引用本身不是对象，故不可能有顶层const</p>
</li>
</ul>
</li>
<li><p>带const和不带const的两个函数可以同时存在，相当于函数重载。  </p>
</li>
<li><p>constexpr和常量表达式</p>
<ul>
<li>常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式；一个对象是不是常量表达式是由它的数据类型（要有const）和初始值（编译时就能得到结果）共同决定的；</li>
<li>C++11规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式；</li>
<li>声明为constexpr的变量一定是一个常量，并且必须用常量表达式初始化。即如果认定变量是一个常量表达式，那就把它声明成constexpr类型</li>
<li>指针和引用都能定义为constexpr，但指针的初始值必须是nullptr或0或存储于某个固定地址中的对象<ul>
<li>函数体内定义的变量一般存放在非固定地址，因此constexpr指针不能指向这样的变量</li>
<li>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;<span class="comment">//p是一个指向整型常量的指针</span></span><br><span class="line">cosntexpr <span class="type">int</span> *q = <span class="literal">nullptr</span>;<span class="comment">//q是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;const 和 #define 的区别？&#x3D;&#x3D;</p>
</li>
</ul>
<blockquote>
<p>const 和 #define 都可以用于定义常量，但它们在C++中有一些重要的区别：</p>
<ul>
<li>类型检查： const 是一个真正的常量，具有明确的数据类型，编译器会对其进行类型检查。而 #define 是预处理器的一部分，它不具备类型信息，不进行类型检查</li>
<li>调试友好： const 是编译器处理的，所以在调试时可以看到它的值和类型信息。但 #define 是预处理器处理的，在调试时不会显示宏的名称，可能导致调试困难。</li>
<li>作用域： const 变量具有确定的作用域，而 #define 宏定义没有作用域限制，除非使用 #undef 取消宏定义，否则宏将在整个编译单元内保持有效。这可能导致命名冲突</li>
<li>内存占用： const 变量会占用内存空间，因为它们是真正的变量。而 #define 宏只在编译时进行文本替换，不会分配内存空间。</li>
<li>使用场景： const 常量更适用于基本数据类型、指针和对象。而 #define 宏定义除了用于定义常量外，还可以用于定义条件编译指令、函数宏等。</li>
</ul>
</blockquote>
<h4 id="class、union、struct"><a href="#class、union、struct" class="headerlink" title="class、union、struct"></a>class、union、struct</h4><p><code>class</code>、<code>union</code>和<code>struct</code>都是C++中用于定义用户自定义类型的关键字。</p>
<p><strong><code>class</code></strong></p>
<ul>
<li><code>class</code>用于定义类，可以包含数据成员和成员函数。</li>
<li>默认情况下，<code>class</code>的数据成员和成员函数是私有（private）的，只能通过类的成员函数进行访问和修改。</li>
</ul>
<p><strong><code>union</code></strong></p>
<ul>
<li><code>union</code>用于定义联合体，可以包含多个数据成员。</li>
<li>所有<code>union</code>的数据成员共享同一块内存空间，因此在同一时间只能存储一个数据成员的值。</li>
<li>默认情况下，<code>union</code>的数据成员是公共（public）的。</li>
<li>通常，<code>union</code>用于节省内存或实现底层数据操作。</li>
<li>在C++中，<code>union</code>可以包含构造函数、析构函数和其他成员函数，但这会使使用变得复杂。</li>
</ul>
<p><strong><code>struct</code></strong></p>
<ul>
<li><code>struct</code>用于定义结构体，可以包含数据成员和成员函数。</li>
<li>默认情况下，<code>struct</code>的数据成员和成员函数是公共（public）的。</li>
<li>在C++中，<code>struct</code>和<code>class</code>的功能几乎相同，只是默认的访问控制不同。<code>struct</code>通常用于表示简单的数据结构，而<code>class</code>用于实现面向对象编程的特性。</li>
<li>结构体可以有构造函数、析构函数以及其他特殊成员函数。</li>
</ul>
<p>&#x3D;&#x3D;C++和C的struct区别&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>C语言中：struct是用户自定义数据类型；C++中struct是抽象数据类型（ADT）</li>
<li>C中struct是没有权限的设置，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员<strong>不可以是函数</strong></li>
<li>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</li>
</ul>
</blockquote>
<h4 id="数据类型和类型转换"><a href="#数据类型和类型转换" class="headerlink" title="数据类型和类型转换"></a>数据类型和类型转换</h4><h5 id="怎样判断两个浮点数是否相等"><a href="#怎样判断两个浮点数是否相等" class="headerlink" title="怎样判断两个浮点数是否相等"></a>怎样判断两个浮点数是否相等</h5><ul>
<li>在 C++ 中，直接使用等于运算符 <code>==</code> 来比较两个浮点数是否相等通常是不安全的，因为浮点数在计算机中的表示和计算可能会引入一定程度的误差。</li>
<li>可以定义一个足够小的容差值（epsilon），并比较两个浮点数的差值是否小于容差值<ul>
<li>可以使用标准库中的 <code>std::numeric_limits&lt;float&gt;::epsilon()</code> 来获取机器的容差值</li>
</ul>
</li>
</ul>
<h5 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h5><ul>
<li><p>常见隐式转换</p>
<ul>
<li><p><strong>数组自动转换成指向数组首元素的指针</strong>。</p>
<ul>
<li>当数组被用作<code>decaltype</code>的参数，或作为取地址符、<code>sizeof</code>等运算符的对象时，上述转换不会发生；</li>
</ul>
</li>
<li><p><strong>整数提升</strong>：将较小的整数类型（如 <code>char</code> 和 <code>short</code>）转换为较大的整数类型（如 <code>int</code> 或 <code>long</code>）。</p>
</li>
<li><p><strong>算术转换</strong>：在算术表达式中将较低级别的算术类型转换为较高级别的算术类型。例如，将 <code>float</code> 转换为 <code>double</code>，或将 <code>int</code> 转换为 <code>float</code>。</p>
</li>
<li><p><strong>转换为布尔类型</strong>：将算术类型、指针类型或类类型转换为布尔类型。</p>
</li>
<li><p><strong>函数参数和返回值的隐式转换</strong>：当传递不同类型的实参给函数时，或者返回与函数声明中指定的返回类型不匹配的类型时，会发生隐式转换。</p>
</li>
<li><p><strong>指针转换</strong>：</p>
<ul>
<li><p>常量整数值0或字面值nullptr能转换成任意指针类型。</p>
</li>
<li><p>指向任意非常量的指针能转换为void *，指向任意对象的指针能转换为const void *</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>消除隐式转换的方法：</p>
<ul>
<li><strong>使用显式类型转换</strong>：通过使用 C++ 提供的显式类型转换操作符（如 <code>static_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code> 和 <code>dynamic_cast</code>）来指示需要进行的类型转换。</li>
<li><strong>使用 C++11 引入的 <code>explicit</code> 关键字</strong>：在类构造函数或转换函数前添加 <code>explicit</code> 关键字，避免不必要的隐式类型转换，提高代码的可读性和安全性。</li>
<li><strong>注意函数参数和返回值的类型</strong>：确保函数参数和返回值的类型与调用和实现时所使用的类型匹配，避免函数调用时发生意外的隐式类型转换。</li>
<li><strong>使用类型别名或 <code>auto</code> 关键字</strong>：通过使用类型别名或 <code>auto</code> 关键字来推导类型，可以确保变量的类型与其初始化值相匹配，避免不必要的隐式类型转换。</li>
</ul>
</li>
</ul>
<h5 id="四种显示转换"><a href="#四种显示转换" class="headerlink" title="四种显示转换"></a>四种显示转换</h5><ul>
<li><p>命名的强制类型转换：<code>cast-name&lt;type&gt;(expression)</code>；</p>
</li>
<li><p><strong>static_cast</strong>：最常用的类型转换运算符，用于在相关类型之间进行转换，例如整数和浮点数、指向基类和指向派生类的指针等。</p>
<ul>
<li>只要不包含底层const，都可以用static_cast</li>
<li>static_cast 在编译时完成转换，如果转换无法进行，编译器会报错</li>
</ul>
</li>
<li><p><strong>const_cast</strong>：只能改变运算对象的底层const，对于将常量对象转换成非常量的行为，称之为“去掉const性质”。</p>
<ul>
<li>注意：使用 const_cast 去掉 const 属性后修改原本为常量的对象是未定义行为。</li>
</ul>
</li>
<li><p>dynamic_cast：动态类型转换。只能用于含有虚函数的类，用于安全地在类的继承层次结构中进行指针或引用的转换（从基类到派生类）。</p>
<ul>
<li>在进行向下转换时，dynamic_cast 会在运行时检查转换是否合法。</li>
</ul>
</li>
<li><p>reinterpret_cast：几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用。</p>
</li>
</ul>
<p>&#x3D;&#x3D;为什么不适用c语言的强制转换？&#x3D;&#x3D;  </p>
<p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。  </p>
<h5 id="auto和decltype类型说明符"><a href="#auto和decltype类型说明符" class="headerlink" title="auto和decltype类型说明符"></a>auto和decltype类型说明符</h5><p><code>auto</code> 和 <code>decltype</code> 是 C++11 引入的两个类型推导关键字，它们用于在编译时根据表达式或变量的类型自动推导类型。</p>
<ul>
<li><code>auto</code> 关键字用于自动推导变量的类型。它可以根据变量的初始化表达式来推导变量的类型。使用 <code>auto</code> 时必须提供<strong>初始化表达式</strong>。</li>
<li><code>decltype</code>： <code>decltype</code> 关键字用于根据表达式的类型推导出一个类型。与 <code>auto</code> 不同，<code>decltype</code> <strong>不需要变量</strong>，它仅根据给定表达式的类型推导出相应的类型。<ul>
<li>**decaltype((variable))<strong>的结果永远是引用（因为编译器会把（variable）当作一个表达式）；而</strong>dycaltype(variable)**结果只有当variable本身就是一个引用时才是引用。</li>
</ul>
</li>
</ul>
<h5 id="null与nullptr区别"><a href="#null与nullptr区别" class="headerlink" title="null与nullptr区别"></a>null与nullptr区别</h5><p><code>NULL</code> 和 <code>nullptr</code> 都是表示空指针的常量。</p>
<ul>
<li><p><code>NULL</code></p>
<ul>
<li><p><code>NULL</code> 在 C 和 C++ 中都可用，通常被定义为整数 0 或者类型为 <code>void*</code> 的空指针。</p>
</li>
<li><p>在 C++ 中，<code>NULL</code> 的确切类型取决于实现。它可以是一个整数，也可以是 <code>void*</code> </p>
</li>
<li><p>由于 <code>NULL</code> 可能是一个整数，它可能会导致类型推断和函数重载的问题。</p>
</li>
</ul>
</li>
<li><p><code>nullptr</code></p>
<ul>
<li><p><code>nullptr</code> 是 C++11 引入的新关键字，专门用于表示空指针。</p>
</li>
<li><p><code>nullptr</code> 的类型是 <code>std::nullptr_t</code>，它可以隐式转换为任何指针类型，但不能隐式转换为整数类型。</p>
</li>
<li><p>使用 <code>nullptr</code> 可以避免 <code>NULL</code> 导致的类型推断和函数重载的问题。</p>
</li>
</ul>
</li>
</ul>
<h4 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h4><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><ul>
<li>引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。  </li>
<li>引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。  </li>
<li>引用就是C++对C语言的重要扩充。</li>
</ul>
<h5 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h5><ul>
<li><p>左值和右值是表达式的属性，一般而言一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值</p>
<ul>
<li>左值：能对表达式取地址、或具名对象&#x2F;变量。一般指表达式结束后依然存在的持久对象  </li>
<li>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的<strong>临时对象</strong>。</li>
</ul>
</li>
<li><p>左值引用： 左值引用是传统的C++引用，它绑定到左值上。</p>
</li>
<li><p>右值引用，就是绑定到右值的引用</p>
<ul>
<li>通过 &amp;&amp; 而非 &amp; 来获得右值引用</li>
<li>绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期 </li>
<li>右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。  </li>
<li>右值引用主要用于实现移动语义和完美转发。</li>
</ul>
</li>
<li><p>常规引用（左值引用）不能绑定到<strong>要求转换的表达式</strong>、<strong>字面常量</strong>或者<strong>返回右值的表达式</strong>，但右值引用有着完全相反的绑定特性，<strong>可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用绑定到一个左值上</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;     <span class="comment">// 正确, r引用i</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr = i;   <span class="comment">// 错误, 不能将一个右值引用绑定到左值上</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = i * <span class="number">42</span>; <span class="comment">// 错误: i * 42 是一个右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = i * <span class="number">42</span>; <span class="comment">// 正确： 我们可以将一个const的引用绑定到右值上</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;  <span class="comment">// 正确：将rr2绑定到右值上</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>std::move 和 std::forward</p>
<ul>
<li><code>std::move</code> 用于将左值转换为右值引用，从而允许<strong>移动语义</strong>。移动语义可以提高性能，因为它允许编译器在某些情况下避免复制，如临时对象或不再需要的对象。当使用 <code>std::move</code> 时，通常意味着对象的所有权被转移，原对象可能处于搬移后的状态。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec2 = std::<span class="built_in">move</span>(vec1); <span class="comment">// 移动 vec1 的内容到 vec2，避免复制</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>std::forward</code> 用于实现完美转发，它是一种将参数的类型和值类别（左值或右值）原封不动地传递给另一个函数的技术。这在泛型编程和模板中非常有用，特别是当我们不知道参数的确切类型和值类别时。</li>
</ul>
</li>
</ul>
<h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><ul>
<li>存放变量的地址，通过地址能找到所需的变量单元。  </li>
<li>优先级：()&gt;[]&gt; *，即有括号就先看括号，然后是数组，然后是指针</li>
</ul>
<p>&#x3D;&#x3D;区别以下指针类型&#x3D;&#x3D;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">10</span>]</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>]</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">p</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(*p)</span><span class="params">(<span class="type">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>int *p[10]表示存放指针的数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</li>
<li>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</li>
<li>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</li>
<li>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</li>
</ul>
</blockquote>
<h5 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h5><blockquote>
<ol>
<li>指针有自己的一块空间，而引用只是一个别名；  </li>
<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；  </li>
<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；  </li>
<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；  </li>
<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；  </li>
<li>指针可以有多级指针（**p），而引用只有一级；  </li>
<li>指针和引用使用++运算符的意义不一样；  </li>
<li>.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露 。</li>
</ol>
</blockquote>
<h5 id="指针和引用之间如何转换"><a href="#指针和引用之间如何转换" class="headerlink" title="指针和引用之间如何转换"></a>指针和引用之间如何转换</h5><p>在C++中，指针和引用之间不能直接转换，因为它们在底层实现和使用方式上有本质区别。但是可以通过一些方法在它们之间进行间接转换。</p>
<p>从引用到指针的转换： 要将引用转换为指针，可以使用取址操作符（&amp;）来获取引用所指对象的地址。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = x;       <span class="comment">// ref 是 x 的引用</span></span><br><span class="line"><span class="type">int</span> *ptr = &amp;ref;    <span class="comment">// ptr 是指向 x 的指针</span></span><br></pre></td></tr></table></figure>

<p>从指针到引用的转换： 要将指针转换为引用，可以使用解引用操作符（*）来获取指针所指向的对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *ptr2 = &amp;y;     <span class="comment">// ptr2 是指向 y 的指针</span></span><br><span class="line"><span class="type">int</span> &amp;ref2 = *ptr2;  <span class="comment">// ref2 是 y 的引用</span></span><br></pre></td></tr></table></figure>

<h5 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a><strong>智能指针</strong></h5><ul>
<li><p>智能指针主要用于管理在堆上分配的内存，智能指针实际上就是一个类，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。  </p>
</li>
<li><p>C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。  </p>
</li>
<li><p>四个智能指针：auto_ptr, shared_ptr, weak_ptr, unique_ptr  </p>
<ul>
<li><p><strong>auto_ptr</strong>(c++98方案，c++11已经放弃）  ，采用所有权模式。  </p>
</li>
<li><p><strong>unique_ptr</strong>(替换auto_ptr)  ：</p>
<ul>
<li>由于它不能被复制，只能被转移，因此保证同一时间内只有一个智能指针可以指向该对象。</li>
<li>unique_ptr在作用域结束时自动释放它所管理的内存，可以避免资源泄露（如“以new创建对象后因为发生异常而忘记调用delete”  ）</li>
</ul>
</li>
<li><p><strong>shared_ptr</strong>：实现共享式拥有，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。  </p>
<blockquote>
<p>成员函数：</p>
<p>use_count 返回引用计数的个数</p>
<p>unique 返回是否是独占所有权( use_count 为 1)</p>
<p>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
<p>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
<p>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr</p>
<p>sp(new int(1)); sp 与 sp.get()是等价的  </p>
</blockquote>
</li>
<li><p><strong>weak_ptr</strong>：不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象，它的构造和析构不会引起引用记数的增加或减少，是用来解决shared_ptr相互引用时的死锁问题。</p>
<p>不能通过weak_ptr直接访问对象的方法，应该先把它转化为shared_ptr。</p>
</li>
</ul>
</li>
</ul>
<h5 id="智能指针内存泄漏问题"><a href="#智能指针内存泄漏问题" class="headerlink" title="智能指针内存泄漏问题"></a>智能指针内存泄漏问题</h5><ul>
<li>产生原因：当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。  </li>
<li>解决方法：引入了weak_ptr弱指针，它的构造和析构不会引起引用记数的增加或减少，从而不会对对象的内存进行管理，其类似一个普通指针。</li>
</ul>
<h5 id="指针和数组的区别"><a href="#指针和数组的区别" class="headerlink" title="指针和数组的区别"></a>指针和数组的区别</h5><table>
<thead>
<tr>
<th>指针</th>
<th>数组</th>
</tr>
</thead>
<tbody><tr>
<td>保存数据的地址</td>
<td>保存数据</td>
</tr>
<tr>
<td>间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据</td>
<td>直接访问数据</td>
</tr>
<tr>
<td>通常用于动态的数据结构</td>
<td>通常用于固定数目且数据类型 相同的元素</td>
</tr>
<tr>
<td>通过Malloc分配内存，free释放内存</td>
<td>隐式的分配和删除</td>
</tr>
<tr>
<td>可以指向静态或动态分配的内存</td>
<td>内存是在声明数组时静态分配（栈或全局&#x2F;静态存储区）</td>
</tr>
<tr>
<td>使用 sizeof 运算符得到指针大小：4字节（32位机）</td>
<td>使用 sizeof 运算符计算数组的大小（字节数）</td>
</tr>
</tbody></table>
<h5 id="野指针和悬挂指针"><a href="#野指针和悬挂指针" class="headerlink" title="野指针和悬挂指针"></a>野指针和悬挂指针</h5><ul>
<li><p>野指针：指向无效内存区域的指针。 </p>
</li>
<li><p>造成野指针的原因</p>
<ul>
<li>指针变量没有被初始化（如果值不定，可以初始化为nullptr）  </li>
<li>指针被free或者delete后，没有置为nullptr, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL。</li>
<li>指针操作超越了变量的作用范围，比如返回指向栈内存中局部变量的指针就是野指针。</li>
</ul>
</li>
<li><p>如何避免野指针</p>
<ul>
<li>初始化指针：在定义指针时，将其初始化为nullptr</li>
<li>使用智能指针自动管理内存：当智能指针的生命周期结束时，会自动释放指向的内存</li>
<li>在释放内存后将指针设为nullptr：使用<code>delete</code>释放内存后将原始指针设置为<code>nullptr</code>。这样可以防止对已释放内存的意外访问。</li>
<li>不要返回局部变量的地址：局部变量在函数返回后可能被销毁，因此指向它们的指针将成为野指针。</li>
<li>检查指针有效性：在使用指针之前，检查它们是否有效。例如，确保指针不是nullptr</li>
<li>谨慎使用指针算术：在进行指针运算时要特别小心，以避免意外访问无效内存地址。</li>
</ul>
</li>
<li><p>悬挂指针：指针指向一个已经释放的地址空间。</p>
</li>
</ul>
<h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><ul>
<li><p>函数指针指向的是函数而不是对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pf 指向一个函数，该函数的参数是两个const类型的引用，返回值是bool类型</span></span><br><span class="line"><span class="comment">// 该函数的类型是 bool(const string&amp;, const string&amp;)。声明指向函数的指针，用指针替换函数名：</span></span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);  <span class="comment">// 未初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用函数指针</strong></p>
<ul>
<li>当使用函数名作为一个值时，函数自动转换为指针</li>
<li>可以直接使用指向函数的指针调用该函数，无需解引用指针</li>
<li>在指向不同函数类型的指针之间不存在转换</li>
<li><strong>函数指针形参</strong>：不能定义函数类型形参，但<strong>形参可以是指向函数的指针</strong>，当传入函数作为实参时，它将自动转换为指针</li>
<li><strong>返回指向函数的指针</strong>：不能返回函数类型，但<strong>可以返回指向函数类型的指针</strong>，返回类型不会自动转换为指针，必须<strong>显式地</strong>将返回类型指定为指针类型</li>
</ul>
</li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="函数的定义和声明"><a href="#函数的定义和声明" class="headerlink" title="函数的定义和声明"></a>函数的定义和声明</h5><ul>
<li>定义<ul>
<li><strong>自动对象</strong>（automatic object）：只存在于块执行期间的对象，<strong>形参是自动对象</strong>。</li>
<li><strong>局部静态对象</strong>（local static object）：在第一次执行经过对象定义前进行了初始化，函数结束时不会被销毁，在程序终止时被销毁，通过将局部变量定义为 <strong>static</strong> 来获得此类对象。</li>
</ul>
</li>
<li>声明：函数只能定义一次，但可以声明多次，建议<strong>在头文件中声明，在源文件中定义</strong>。</li>
</ul>
<h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><ul>
<li><p>形参和实参</p>
<ul>
<li>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此形参只在函数内部有效。 </li>
<li>实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。</li>
<li>实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。</li>
<li>函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</li>
<li>当形参和实参不是指针类型时，在函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。</li>
</ul>
</li>
<li><p>传值：通常会将输入的参数拷贝一份作为临时变量来操作，消耗一定的内存和时间。适用于基本数据类型（如 int、float、char 等）和较小的结构体。对于较大的数据结构（如大数组、大容器等），传值可能会导致性能下降。</p>
</li>
<li><p>传指针：将指针的副本传递给函数，函数接收到的是指向原始数据的指针</p>
<ul>
<li>允许修改所指向的数据，但不允许修改指针本身</li>
<li>因为传递的是指针的副本，所以在函数内部修改指针不会影响到原始指针</li>
<li>指针可以为<code>nullptr</code>，这可能导致运行时错误。在使用指针之前，需要检查其有效性。</li>
<li>语法较为繁琐，需要使用指针操作符<code>*</code>和<code>-&gt;</code>来访问和修改数据。</li>
</ul>
</li>
<li><p>传引用：将原始数据的别名传递给函数。函数接收到的是原始数据的引用，而不是副本</p>
<ul>
<li>引用传递允许直接修改原始数据，无需额外的操作符</li>
<li>引用必须在创建时初始化，且不能重新绑定到其他对象。因此，引用通常比指针更安全</li>
<li>语法更简洁，无需使用特殊操作符。引用的使用与普通变量相似。</li>
<li>传引用通常适用于较大的数据结构，因为它只需要拷贝一个引用(本质就是一个地址)，无需对整个对象的复制，从而提高了效率。缺点是可能导致意外地修改原对象的值。</li>
</ul>
</li>
<li><p><strong>const</strong>形参和实参</p>
<ul>
<li>传引用的潜在问题是可能导致意外地修改原变量，因此尽量使用<strong>常量引用</strong>作为形参；</li>
<li>当用实参初始化形参时会忽略掉顶层const，即当形参有顶层const时，传给形参常量对象或非常量对象都可以；</li>
<li>可以使用非常量初始化一个底层const对象，反之则不行。</li>
</ul>
</li>
<li><p>数组形参：不允许拷贝数组，所以无法以值传递的方式使用数组形参，使用数组时通常会被转换成指针，所以当向函数传递一个数组时，实际上传递的是指向数组第一个元素的指针。</p>
</li>
</ul>
<h5 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h5><ul>
<li>可以返回临时变量，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存无关。</li>
<li>不要返回局部对象的引用或指针，因为函数返回时临时变量被销毁，导致指针指向一块无意义的地址空间。</li>
<li>调用一个<strong>返回引用的函数得到的是左值</strong>，其他返回类型得到右值。</li>
<li>因为数组不能被拷贝，所以函数不能返回数组，但可以<strong>返回数组的指针或引用</strong>。</li>
<li>主函数 main 的返回值：main 函数允许没有 return 语句直接结束，编译器会隐式插入 return 0。</li>
</ul>
<h5 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h5><ul>
<li><strong>内联函数</strong>：inline 函数避免函数调用的开销，通常旨在优化规模较小、流程直接、调用频繁的函数。</li>
<li><strong>constexpr函数</strong>：可用于常量表达式的函数，<code>return</code> 类型和每个形参的类型必须是字面值类型，且函数主体必须有且只有一条 <code>return</code> 语句。</li>
</ul>
<h5 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h5><ul>
<li>匹配顺序<ol>
<li>精确匹配（实参和形参类型相同、实参从数组或函数转换成对应的指针、向实参添加顶层 const 或从实参中删除顶层 const）</li>
<li>通过 const 转换实现的匹配</li>
<li>通过类型提升实现的匹配</li>
<li>通过算术类型转换或指针转换实现的匹配</li>
<li>通过类类型转换实现的匹配</li>
</ol>
</li>
</ul>
<h5 id="实现一个函数先于main函数运行"><a href="#实现一个函数先于main函数运行" class="headerlink" title="实现一个函数先于main函数运行"></a>实现一个函数先于main函数运行</h5><ul>
<li><p>做法1：<code>_attribute__((constructor))</code> 和 <code>__attribute__((destructor))</code> 是GCC编译器提供的特殊属性，可以用此属性声明一个函数（返回值之后函数名之前），用于指定某个函数在程序启动之前（主函数main()执行之前）或退出之后（main()函数执行结束后）自动执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__((constructor)) <span class="built_in">init_function</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before main()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>做法2：在 C++ 中，可以使用全局对象的构造函数在 main 函数之前运行一些代码。应谨慎使用，因为全局对象的构造函数和析构函数的调用顺序可能受到编译器和链接器的影响。</p>
</li>
</ul>
<p>&#x3D;&#x3D;在main执行之前和之后执行的代码可能是什么？&#x3D;&#x3D;</p>
<blockquote>
<p>main函数执行之前，主要就是初始化系统相关资源：</p>
<ul>
<li>设置栈指针、初始化静态static变量和global全局变量、将未初始化部分的全局变量赋初值、全局对象初始化、将main函数的参数argc，argv等传递给main函数</li>
</ul>
<p>main函数执行之后：全局对象的析构函数</p>
</blockquote>
<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><h5 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h5><ul>
<li><p>IO类</p>
<ul>
<li>头文件：iostream、fstream、sstream</li>
</ul>
</li>
<li><p>C++不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO，这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等；</p>
</li>
<li><p>IO对象不能拷贝或赋值，也不能将形参或返回类型设置为流类型</p>
</li>
<li><p>代码通常应该在使用一个流之前检查它是否处于良好状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word);</span><br></pre></td></tr></table></figure>
</li>
<li><p>管理输出缓冲：有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; endl;    <span class="comment">// 输出内容和一个换行，然后刷新缓冲区</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; flush;    <span class="comment">// 输出内容，然后刷新缓冲区</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; ends &lt;&lt; <span class="number">1</span>;    <span class="comment">// 输出内容和一个空字符，然后刷新缓冲区。</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;cout和printf有什么区别？&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>cout<ul>
<li>cout&lt;&lt;是类<code>std::ostream</code>的全局对象</li>
<li>其后可以跟不同的类型，因为cout&lt;&lt;已存在针对各种类型数据做了重载，更加智能和安全</li>
<li>cout有缓冲输出，flush立即强迫缓冲输出，endl换行再强迫缓冲输出；</li>
</ul>
</li>
<li>printf<ul>
<li>printf 是C标准库函数</li>
<li>printf是行缓冲输出，不是无缓冲输出</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>关联输入和输出流</p>
<ul>
<li>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标椎库将cout和cin关联在一起</li>
<li>istream和ostream类型的tie成员都只能接收ostream *类型参数</li>
</ul>
</li>
<li><p>文件输入输出：ifstream；ofstream；fstream</p>
<ul>
<li>用IO运算符（&lt;&lt;和&gt;&gt;）来读写文件</li>
<li>用getline从一个ifstream读取数据</li>
<li>自动构造和析构：当一个fstream对象被销毁时，close会自动被调用</li>
<li>成员函数open和close：如果定义了一个空文件流对象，可以随后调用open来将它与文件关联起来，<strong>首先必须关闭已经关联的文件</strong></li>
</ul>
</li>
<li><p>string流：istringstream、ostringstream、stringstream</p>
</li>
</ul>
<h5 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h5><ul>
<li>标准库中的顺序容器：vector、deque、list、forward_list、array、string</li>
</ul>
<p>&#x3D;&#x3D;string与C语言中的 char *有什么区别吗？它是如何实现的？&#x3D;&#x3D;</p>
<blockquote>
<p>string继承自basic_string,其实是对char进行了封装，封装的string包含了char数组，容量，长度等等属性。</p>
<p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间，然后将原字符串拷贝过去，并加上新增的内容。</p>
</blockquote>
<h5 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h5><h5 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h5><ul>
<li><p>大多数都独立于任何特定的容器，它们可用于不同类型的容器和不同类型的元素</p>
</li>
<li><p>算法不直接操作容器，而是遍历有两个迭代器指定的一个元素范围</p>
</li>
<li><p>算法可能改变容器中保存元素的值，也可能在容器内移动元素，但是永远不会直接添加或删除元素，也永远不会改变底层容器的大小，；</p>
</li>
<li><p>标准库定义了一类特殊的迭代器（<strong>插入器</strong>），给这类迭代器赋值会在底层的容器上执行插入操作</p>
</li>
<li><p>只读算法：find、count、accumulate、equal等</p>
</li>
<li><p>写容器元素的算法：fill、copy、replace等</p>
</li>
<li><p>重排容器元素的算法：sort+unique+erase</p>
</li>
<li><p>参数绑定：bind</p>
</li>
<li><p>优先使用<strong>成员函数版本的算法</strong>，而不是通用算法，因为代价太大。</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://lyfu0814.github.io/2023/11/08/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E8%A8%80/" title="基本语言">https://lyfu0814.github.io/2023/11/08/基本语言/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/08/%E7%B1%BB/" rel="prev" title="类">
                  <i class="fa fa-angle-left"></i> 类
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/11/08/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" rel="next" title="模板与泛型编程">
                  模板与泛型编程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">55k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">50 分钟</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
