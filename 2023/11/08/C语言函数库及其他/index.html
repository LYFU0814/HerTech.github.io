<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lyfu0814.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="strcpy函数和strncpy函数的区别strcpy 和 strncpy 是 C 语言中的字符串复制函数，它们用于将一个字符串复制到另一个字符串。这两个函数的主要区别在于它们的安全性和复制方式：  strcpy 函数用于将源字符串完整地复制到目标字符串。它没有限制复制的字符数量，所以会一直复制源字符串的字符直到遇到空字符（\0）。当目标字符串的空间不足以容纳源字符串时，就会导致缓冲区溢出。这">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言函数库及其他">
<meta property="og:url" content="https://lyfu0814.github.io/2023/11/08/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%BA%93%E5%8F%8A%E5%85%B6%E4%BB%96/index.html">
<meta property="og:site_name" content="HerTech">
<meta property="og:description" content="strcpy函数和strncpy函数的区别strcpy 和 strncpy 是 C 语言中的字符串复制函数，它们用于将一个字符串复制到另一个字符串。这两个函数的主要区别在于它们的安全性和复制方式：  strcpy 函数用于将源字符串完整地复制到目标字符串。它没有限制复制的字符数量，所以会一直复制源字符串的字符直到遇到空字符（\0）。当目标字符串的空间不足以容纳源字符串时，就会导致缓冲区溢出。这">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-08T03:08:20.000Z">
<meta property="article:modified_time" content="2023-11-08T03:36:38.246Z">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lyfu0814.github.io/2023/11/08/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%BA%93%E5%8F%8A%E5%85%B6%E4%BB%96/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lyfu0814.github.io/2023/11/08/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%BA%93%E5%8F%8A%E5%85%B6%E4%BB%96/","path":"2023/11/08/C语言函数库及其他/","title":"C语言函数库及其他"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C语言函数库及其他 | HerTech</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="HerTech" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">HerTech</p>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/uploads/logo.jpg" alt="HerTech">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#strcpy%E5%87%BD%E6%95%B0%E5%92%8Cstrncpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">strcpy函数和strncpy函数的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#memset-%EF%BC%8Cmemcpy-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">memset ，memcpy 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sizeof-%E5%92%8C-strlen%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">sizeof 和 strlen的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#strcpy%E3%80%81sprintf-%E4%B8%8E-memcpy-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">strcpy、sprintf 与 memcpy 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cout%E5%92%8Cprintf%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">cout和printf的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="nav-number">6.</span> <span class="nav-text">链接属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RTTI"><span class="nav-number">7.</span> <span class="nav-text">RTTI</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">c++函数调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">9.</span> <span class="nav-text">c++处理返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E4%B8%8E%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">c++与其他语言的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">11.</span> <span class="nav-text">C++11新特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">哈希冲突的解决方法</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">uu的博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_42659457" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42659457" rel="noopener me" target="_blank"><i class="csdn fa-fw"></i>CSDN</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lyfu0814.github.io/2023/11/08/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%BA%93%E5%8F%8A%E5%85%B6%E4%BB%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HerTech">
      <meta itemprop="description" content="uu的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C语言函数库及其他 | HerTech">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C语言函数库及其他
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-08 11:08:20 / 修改时间：11:36:38" itemprop="dateCreated datePublished" datetime="2023-11-08T11:08:20+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">C++总结</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><span id="more"></span>

<h5 id="strcpy函数和strncpy函数的区别"><a href="#strcpy函数和strncpy函数的区别" class="headerlink" title="strcpy函数和strncpy函数的区别"></a>strcpy函数和strncpy函数的区别</h5><p>strcpy 和 strncpy 是 C 语言中的字符串复制函数，它们用于将一个字符串复制到另一个字符串。这两个函数的主要区别在于它们的安全性和复制方式：</p>
<ul>
<li><code>strcpy</code> 函数用于将源字符串完整地复制到目标字符串。它没有限制复制的字符数量，所以会一直复制源字符串的字符直到遇到空字符（<code>\0</code>）。当目标字符串的空间不足以容纳源字符串时，就会导致缓冲区溢出。这可能导致程序崩溃或安全漏洞，如代码注入攻击。因此，<code>strcpy</code> 在很多情况下被认为是不安全的。</li>
<li><code>strncpy</code> 函数用于将源字符串的前 N 个字符复制到目标字符串。这个 N 由函数的第三个参数指定，它限制了复制的字符数量，避免缓冲区溢出。当指定的字符数量小于源字符串长度时，<code>strncpy</code> 不会在目标字符串的末尾添加空字符。这可能导致目标字符串不以空字符结尾，从而产生未定义行为。因此，在使用 <code>strncpy</code> 时，需要确保在复制后手动添加空字符，或确保目标字符串足够大以容纳源字符串和空字符。</li>
</ul>
<h5 id="memset-，memcpy-的区别"><a href="#memset-，memcpy-的区别" class="headerlink" title="memset ，memcpy 的区别"></a>memset ，memcpy 的区别</h5><p><code>memset</code>和<code>memcpy</code>都是C语言库函数，分别用于设置内存块的内容和复制内存块，这两个函数在C++中也可以使用。</p>
<ul>
<li><code>memset</code>函数用于设置内存块的内容。它将一段内存中的每个字节设置为指定的值。它常用于将数组或结构体初始化为零或其他特定值。<ul>
<li>原型：<code>void* memset(void *str, int c, size_t n) ;</code></li>
</ul>
</li>
<li><code>memcpy</code>函数用于复制内存块。它从源内存块复制指定数量的字节到目标内存块。它常用于将一个数组或结构体的内容复制到另一个数组或结构体。<ul>
<li>原型：<code>void* memcpy(void* dest, const void* src, size_t count);</code></li>
</ul>
</li>
<li>补充：<ul>
<li>对于具有non-trivial构造函数或析构函数的类对象，直接使用<code>memset</code>或<code>memcpy</code>可能会破坏对象的状态或导致未定义行为。</li>
<li><code>memcpy</code>和<code>memmove</code>之间的主要区别在于它们<strong>处理重叠内存区域</strong>的方式。如果内存区域可能重叠，应使用<code>memmove</code>以确保正确的行为。如果内存区域不重叠，可以使用<code>memcpy</code>获得更高的性能。</li>
</ul>
</li>
</ul>
<h5 id="sizeof-和-strlen的区别"><a href="#sizeof-和-strlen的区别" class="headerlink" title="sizeof 和 strlen的区别"></a>sizeof 和 strlen的区别</h5><p><code>sizeof</code>和<code>strlen</code>是C和C++中两个用于获取大小的不同操作符和函数。</p>
<ul>
<li><p><code>sizeof</code></p>
<ul>
<li><p><code>sizeof</code>是一个编译时操作符，用于计算类型或对象所占用的字节数。</p>
</li>
<li><p><code>sizeof</code>可以用于任何数据类型，包括基本类型、数组、结构体和类。</p>
</li>
<li><p>对于数组，<code>sizeof</code>会返回整个数组所占用的字节数，而不仅仅是一个指针的大小。</p>
</li>
<li><p><code>sizeof</code>的结果在编译时就已经确定，不会在运行时改变。</p>
</li>
</ul>
<blockquote>
<p>指针的大小永远是固定的，取决于处理器位数，32位就是 4 字节，64位就是 8 字节</p>
<p>字符串数组要算上末尾的 ‘\0’</p>
<p>struct 结构体要考虑字节对齐</p>
</blockquote>
</li>
<li><p><code>strlen</code></p>
<ul>
<li><code>strlen</code>是一个运行时函数，用于计算C风格字符串（以空字符’\0’结尾的字符数组）的长度。</li>
<li><code>strlen</code>函数的原型：<code>size_t strlen(const char* str);</code></li>
<li><code>strlen</code>只适用于C风格字符串，不能用于其他数据类型。</li>
<li><code>strlen</code>的结果可能在运行时改变，取决于字符串的实际内容。</li>
</ul>
</li>
</ul>
<h5 id="strcpy、sprintf-与-memcpy-的区别"><a href="#strcpy、sprintf-与-memcpy-的区别" class="headerlink" title="strcpy、sprintf 与 memcpy 的区别"></a>strcpy、sprintf 与 memcpy 的区别</h5><p><code>strcpy</code>、<code>sprintf</code>和<code>memcpy</code>都是C语言库函数，用于处理字符串和内存块的操作。</p>
<ul>
<li><code>strcpy</code>：<code>strcpy</code>函数用于复制一个以空字符结尾的字符串。它将源字符串中的字符逐个复制到目标字符串，直到遇到空字符。空字符也会被复制到目标字符串。</li>
<li><code>sprintf</code>：<code>sprintf</code>函数用于格式化输出。它根据提供的格式字符串将数据格式化为一个字符串。可以将整数、浮点数、字符等格式化为字符串。函数返回存储在目标字符串中的字符数（不包括空字符）。</li>
<li><code>memcpy</code>：<code>memcpy</code>函数用于复制内存块。它从源内存块复制指定数量的字节到目标内存块。它常用于将一个数组或结构体的内容复制到另一个数组或结构体。</li>
</ul>
<h5 id="cout和printf的区别"><a href="#cout和printf的区别" class="headerlink" title="cout和printf的区别"></a>cout和printf的区别</h5><p><code>cout</code>和<code>printf</code>都可以用于C++中的输出操作。</p>
<ul>
<li><p><code>cout</code>：<code>cout</code>是C++标准库的一部分，属于<code>std</code>命名空间。它是<code>std::ostream</code>类的一个实例，用于向标准输出（通常是屏幕）发送数据。可以自动处理类型转换和格式化，使得代码更易读和类型安全。</p>
<blockquote>
<p>会转换为科学计数法</p>
</blockquote>
</li>
<li><p><code>printf</code>：<code>printf</code>是C语言库函数，在C++中也可以使用。用于格式化输出，通常用于向标准输出发送格式化的文本。<code>printf</code>不提供类型安全，容易导致类型不匹配的问题。</p>
</li>
<li><p>性能</p>
<ul>
<li><p><code>cout</code>：<code>cout</code>通常比<code>printf</code>性能略低，因为它涉及到更多的类和函数调用。然而，在大多数情况下，性能差异可以忽略不计。</p>
</li>
<li><p><code>printf</code>：<code>printf</code>通常比<code>cout</code>性能略高，因为它是一个简单的函数调用，直接处理格式字符串和参数列表。</p>
</li>
</ul>
</li>
</ul>
<h5 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h5><table>
<thead>
<tr>
<th>external</th>
<th>internal</th>
<th>none</th>
</tr>
</thead>
<tbody><tr>
<td>全局变量默认拥有external链接 属性</td>
<td>static修饰的变量拥有 internal链接属性</td>
<td>函数体中的变量用于none链接属 性</td>
</tr>
<tr>
<td>拥有external链接属性的变量可被所有文件访问，只需要声明即可</td>
<td>拥有internal属性的变量只能在其定义的文件中被访问</td>
<td>拥有none属性的变量只能在其定义开始处到代码块作用域结束处被访问</td>
</tr>
</tbody></table>
<p>链接属性分为external，internal，none  </p>
<p>给已经定义的变量添加任何链接属性声明(如:extern或static)都是无效的，变量原链接属性保持不变  </p>
<p>对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。 </p>
<h5 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h5><p>RTTI(Run Time Type Identification)即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。  </p>
<p>C++是一种静态类型语言。其数据类型是在编译期就确定的，不能在运行时更改。然而由于面向对象程序设计中多态性的要求，C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。和Java相比，C++要想获得运行时类型信息，只能通过RTTI机制，并且C++最终生成的代码是直接与机器相关的。  </p>
<p>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info  </p>
<ul>
<li>typeid操作符，返回指针和引用所指的实际类型；  <ul>
<li>typeid函数的主要作用就是让用户知道当前的变量是什么类型的，比如使用 typeid(a).name(); 就能知道变量a是什么类型的。typeid()函数的返回类型为typeinfo类型的引用。</li>
</ul>
</li>
<li>dynamic_cast操作符，将基类类型的指针或引用安全地转换为其派生类类型的指针或引用。  <ul>
<li>dynamic_cast转换符只能用于指针或者引用。dynamic_cast转换符只能用于含有虚函数的类。</li>
</ul>
</li>
</ul>
<h5 id="c-函数调用"><a href="#c-函数调用" class="headerlink" title="c++函数调用"></a>c++函数调用</h5><p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。  </p>
<h5 id="c-处理返回值"><a href="#c-处理返回值" class="headerlink" title="c++处理返回值"></a>c++处理返回值</h5><p>生成一个临时变量，把他的引用作为参数传入函数内。 </p>
<h5 id="c-与其他语言的区别"><a href="#c-与其他语言的区别" class="headerlink" title="c++与其他语言的区别"></a>c++与其他语言的区别</h5><ul>
<li>与c语言的区别  <ul>
<li>设计思想上：c是面向过程的结构化编程语言，c++是面向对象的语言  </li>
<li>语法上：<ul>
<li>C++具有封装、继承和多态三个特性；</li>
<li>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</li>
<li>C++支持泛型编程，比如模板类、函数模板等</li>
</ul>
</li>
</ul>
</li>
<li>与python的区别<ul>
<li>Python是脚本语言，是解释执行的，C++是编译语言，需要编译后在特定平台运行。</li>
<li>python可以很方便的跨平台，但是效率没有C++高。</li>
<li>Python使用缩进来区分不同的代码块，C++使用花括号来区分</li>
<li>C++中需要事先定义变量的类型，而Python不需要</li>
</ul>
</li>
</ul>
<p><strong>C++类型安全</strong></p>
<ul>
<li>类型安全：<ul>
<li>类型安全性意味编译器将在编译时类型验证，如果尝试将错误的类型分配给变量，则抛出错误。</li>
<li>类型安全是指同一段内存在不同的地方，会被强制要求使用相同的办法来解释，如1就是int，不能解释为true则为类型安全</li>
<li>很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域，也可以形容程序没有包含隐式类型错误</li>
<li>C&#x2F;C++不是类型安全的语言，Java语言是类型安全的</li>
</ul>
</li>
<li>C语言的类型安全<ul>
<li>只在局部上下文中表现出类型安全，如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换</li>
<li>malloc函数的返回值类型是void*，常常强制类型转换为别的指针类型</li>
</ul>
</li>
<li>C++的类型安全<ul>
<li>操作符new返回的指针类型严格与对象匹配，而不是void*</li>
<li>引入const关键字代替#define constants，const是有类型、有作用域的，而#define constants只是简单的文本替换</li>
<li>一些#define宏可被改写为inline函数，可在类型安全的前提下支持多种类型</li>
<li>C++提供了<strong>dynamic_cast</strong>关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</li>
</ul>
</li>
</ul>
<h5 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h5><ul>
<li><p>auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导  </p>
</li>
<li><p>nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。  </p>
</li>
<li><p>智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。  </p>
</li>
<li><p>初始化列表：使用初始化列表来对类进行初始化  </p>
</li>
<li><p>右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率  </p>
<ul>
<li>移动语义： 移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是”偷”了过来，将自己的指针指向别人的资源，然后将别人的指针修改为 nullptr   </li>
<li>完美转发：  完美转发是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另一个函数，即传入转发函数的是左值对象，目标函数就能获得左值对象，转发函数是右值对象，目标函数就能获得右值对象，而不产生额外的开销</li>
<li>因此转发函数和目标函数参数一般采用引用类型，从而避免拷贝的开销。其次，由于目标函数可能需要能够既接受左值引用，又接受右值引用，所以考虑转发也需要兼容这两种类型  </li>
<li>C++11采用引用折叠的规则，结合新的模板推导规则实现完美转发。</li>
</ul>
</li>
<li><p>atomic原子操作用于多线程资源互斥操作  </p>
</li>
<li><p>新增STL容器array以及tuple</p>
</li>
<li><p>可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上省略号。 </p>
</li>
<li><p>lambda表达式  </p>
<ul>
<li>Lambda表达式定义一个匿名函数，并且可以捕获一定范围内的变量 ， 在需要使用函数对象的地方直接定义和使用。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture_list](parameter_list)<span class="keyword">mutable</span>-&gt;<span class="keyword">return</span>-type&#123;function_body&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>capture_list：捕获列表，指定哪些变量以及如何捕获它们（通过值或引用）。捕获列表可以为空。</li>
<li>parameter_list：参数列表，和普通函数的参数列表一样，指定传递给 lambda 表达式的参数。参数列表可以为空。</li>
<li>mutable：可选关键字，用于标识 lambda 表达式是否可以修改捕获的变量。</li>
<li>return_type：返回类型，可以显式指定，也可以省略。如果省略，编译器会根据函数体中的返回语句自动推导返回类型</li>
<li>function_body：函数体，包含 lambda 表达式的实际代码。</li>
</ul>
</li>
</ul>
<h5 id="哈希冲突的解决方法"><a href="#哈希冲突的解决方法" class="headerlink" title="哈希冲突的解决方法"></a>哈希冲突的解决方法</h5><ul>
<li><p>线性探测</p>
<ul>
<li>使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</li>
</ul>
</li>
<li><p><strong>开链</strong></p>
<ul>
<li>每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</li>
</ul>
</li>
<li><p><strong>再散列</strong></p>
<ul>
<li>发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</li>
</ul>
</li>
<li><p><strong>二次探测</strong></p>
<ul>
<li>使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://lyfu0814.github.io/2023/11/08/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%BA%93%E5%8F%8A%E5%85%B6%E4%BB%96/" title="C语言函数库及其他">https://lyfu0814.github.io/2023/11/08/C语言函数库及其他/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/08/STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" rel="prev" title="STL体系结构">
                  <i class="fa fa-angle-left"></i> STL体系结构
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">55k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">50 分钟</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
