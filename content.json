{"meta":{"title":"HerTech","subtitle":"","description":"uu的博客","author":"","url":"https://LYFU0814.github.io","root":"/"},"pages":[{"title":"categories","date":"2023-11-07T08:53:11.000Z","updated":"2023-11-08T03:07:36.709Z","comments":false,"path":"categories/index.html","permalink":"https://lyfu0814.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-07T08:27:03.000Z","updated":"2023-11-07T08:27:31.542Z","comments":false,"path":"tags/index.html","permalink":"https://lyfu0814.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C语言函数库及其他","slug":"C语言函数库及其他","date":"2023-11-08T03:08:20.000Z","updated":"2023-11-08T03:36:38.246Z","comments":true,"path":"2023/11/08/C语言函数库及其他/","permalink":"https://lyfu0814.github.io/2023/11/08/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%BA%93%E5%8F%8A%E5%85%B6%E4%BB%96/","excerpt":"","text":"strcpy函数和strncpy函数的区别strcpy 和 strncpy 是 C 语言中的字符串复制函数，它们用于将一个字符串复制到另一个字符串。这两个函数的主要区别在于它们的安全性和复制方式： strcpy 函数用于将源字符串完整地复制到目标字符串。它没有限制复制的字符数量，所以会一直复制源字符串的字符直到遇到空字符（\\0）。当目标字符串的空间不足以容纳源字符串时，就会导致缓冲区溢出。这可能导致程序崩溃或安全漏洞，如代码注入攻击。因此，strcpy 在很多情况下被认为是不安全的。 strncpy 函数用于将源字符串的前 N 个字符复制到目标字符串。这个 N 由函数的第三个参数指定，它限制了复制的字符数量，避免缓冲区溢出。当指定的字符数量小于源字符串长度时，strncpy 不会在目标字符串的末尾添加空字符。这可能导致目标字符串不以空字符结尾，从而产生未定义行为。因此，在使用 strncpy 时，需要确保在复制后手动添加空字符，或确保目标字符串足够大以容纳源字符串和空字符。 memset ，memcpy 的区别memset和memcpy都是C语言库函数，分别用于设置内存块的内容和复制内存块，这两个函数在C++中也可以使用。 memset函数用于设置内存块的内容。它将一段内存中的每个字节设置为指定的值。它常用于将数组或结构体初始化为零或其他特定值。 原型：void* memset(void *str, int c, size_t n) ; memcpy函数用于复制内存块。它从源内存块复制指定数量的字节到目标内存块。它常用于将一个数组或结构体的内容复制到另一个数组或结构体。 原型：void* memcpy(void* dest, const void* src, size_t count); 补充： 对于具有non-trivial构造函数或析构函数的类对象，直接使用memset或memcpy可能会破坏对象的状态或导致未定义行为。 memcpy和memmove之间的主要区别在于它们处理重叠内存区域的方式。如果内存区域可能重叠，应使用memmove以确保正确的行为。如果内存区域不重叠，可以使用memcpy获得更高的性能。 sizeof 和 strlen的区别sizeof和strlen是C和C++中两个用于获取大小的不同操作符和函数。 sizeof sizeof是一个编译时操作符，用于计算类型或对象所占用的字节数。 sizeof可以用于任何数据类型，包括基本类型、数组、结构体和类。 对于数组，sizeof会返回整个数组所占用的字节数，而不仅仅是一个指针的大小。 sizeof的结果在编译时就已经确定，不会在运行时改变。 指针的大小永远是固定的，取决于处理器位数，32位就是 4 字节，64位就是 8 字节 字符串数组要算上末尾的 ‘\\0’ struct 结构体要考虑字节对齐 strlen strlen是一个运行时函数，用于计算C风格字符串（以空字符’\\0’结尾的字符数组）的长度。 strlen函数的原型：size_t strlen(const char* str); strlen只适用于C风格字符串，不能用于其他数据类型。 strlen的结果可能在运行时改变，取决于字符串的实际内容。 strcpy、sprintf 与 memcpy 的区别strcpy、sprintf和memcpy都是C语言库函数，用于处理字符串和内存块的操作。 strcpy：strcpy函数用于复制一个以空字符结尾的字符串。它将源字符串中的字符逐个复制到目标字符串，直到遇到空字符。空字符也会被复制到目标字符串。 sprintf：sprintf函数用于格式化输出。它根据提供的格式字符串将数据格式化为一个字符串。可以将整数、浮点数、字符等格式化为字符串。函数返回存储在目标字符串中的字符数（不包括空字符）。 memcpy：memcpy函数用于复制内存块。它从源内存块复制指定数量的字节到目标内存块。它常用于将一个数组或结构体的内容复制到另一个数组或结构体。 cout和printf的区别cout和printf都可以用于C++中的输出操作。 cout：cout是C++标准库的一部分，属于std命名空间。它是std::ostream类的一个实例，用于向标准输出（通常是屏幕）发送数据。可以自动处理类型转换和格式化，使得代码更易读和类型安全。 会转换为科学计数法 printf：printf是C语言库函数，在C++中也可以使用。用于格式化输出，通常用于向标准输出发送格式化的文本。printf不提供类型安全，容易导致类型不匹配的问题。 性能 cout：cout通常比printf性能略低，因为它涉及到更多的类和函数调用。然而，在大多数情况下，性能差异可以忽略不计。 printf：printf通常比cout性能略高，因为它是一个简单的函数调用，直接处理格式字符串和参数列表。 链接属性 external internal none 全局变量默认拥有external链接 属性 static修饰的变量拥有 internal链接属性 函数体中的变量用于none链接属 性 拥有external链接属性的变量可被所有文件访问，只需要声明即可 拥有internal属性的变量只能在其定义的文件中被访问 拥有none属性的变量只能在其定义开始处到代码块作用域结束处被访问 链接属性分为external，internal，none 给已经定义的变量添加任何链接属性声明(如:extern或static)都是无效的，变量原链接属性保持不变 对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。 RTTIRTTI(Run Time Type Identification)即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。 C++是一种静态类型语言。其数据类型是在编译期就确定的，不能在运行时更改。然而由于面向对象程序设计中多态性的要求，C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。和Java相比，C++要想获得运行时类型信息，只能通过RTTI机制，并且C++最终生成的代码是直接与机器相关的。 运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info typeid操作符，返回指针和引用所指的实际类型； typeid函数的主要作用就是让用户知道当前的变量是什么类型的，比如使用 typeid(a).name(); 就能知道变量a是什么类型的。typeid()函数的返回类型为typeinfo类型的引用。 dynamic_cast操作符，将基类类型的指针或引用安全地转换为其派生类类型的指针或引用。 dynamic_cast转换符只能用于指针或者引用。dynamic_cast转换符只能用于含有虚函数的类。 c++函数调用每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。 c++处理返回值生成一个临时变量，把他的引用作为参数传入函数内。 c++与其他语言的区别 与c语言的区别 设计思想上：c是面向过程的结构化编程语言，c++是面向对象的语言 语法上： C++具有封装、继承和多态三个特性； C++相比C，增加多许多类型安全的功能，比如强制类型转换、 C++支持泛型编程，比如模板类、函数模板等 与python的区别 Python是脚本语言，是解释执行的，C++是编译语言，需要编译后在特定平台运行。 python可以很方便的跨平台，但是效率没有C++高。 Python使用缩进来区分不同的代码块，C++使用花括号来区分 C++中需要事先定义变量的类型，而Python不需要 C++类型安全 类型安全： 类型安全性意味编译器将在编译时类型验证，如果尝试将错误的类型分配给变量，则抛出错误。 类型安全是指同一段内存在不同的地方，会被强制要求使用相同的办法来解释，如1就是int，不能解释为true则为类型安全 很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域，也可以形容程序没有包含隐式类型错误 C&#x2F;C++不是类型安全的语言，Java语言是类型安全的 C语言的类型安全 只在局部上下文中表现出类型安全，如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换 malloc函数的返回值类型是void*，常常强制类型转换为别的指针类型 C++的类型安全 操作符new返回的指针类型严格与对象匹配，而不是void* 引入const关键字代替#define constants，const是有类型、有作用域的，而#define constants只是简单的文本替换 一些#define宏可被改写为inline函数，可在类型安全的前提下支持多种类型 C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。 C++11新特性 auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导 nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。 智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。 初始化列表：使用初始化列表来对类进行初始化 右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率 移动语义： 移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是”偷”了过来，将自己的指针指向别人的资源，然后将别人的指针修改为 nullptr 完美转发： 完美转发是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另一个函数，即传入转发函数的是左值对象，目标函数就能获得左值对象，转发函数是右值对象，目标函数就能获得右值对象，而不产生额外的开销 因此转发函数和目标函数参数一般采用引用类型，从而避免拷贝的开销。其次，由于目标函数可能需要能够既接受左值引用，又接受右值引用，所以考虑转发也需要兼容这两种类型 C++11采用引用折叠的规则，结合新的模板推导规则实现完美转发。 atomic原子操作用于多线程资源互斥操作 新增STL容器array以及tuple 可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上省略号。 lambda表达式 Lambda表达式定义一个匿名函数，并且可以捕获一定范围内的变量 ， 在需要使用函数对象的地方直接定义和使用。 1[capture_list](parameter_list)mutable-&gt;return-type&#123;function_body&#125; capture_list：捕获列表，指定哪些变量以及如何捕获它们（通过值或引用）。捕获列表可以为空。 parameter_list：参数列表，和普通函数的参数列表一样，指定传递给 lambda 表达式的参数。参数列表可以为空。 mutable：可选关键字，用于标识 lambda 表达式是否可以修改捕获的变量。 return_type：返回类型，可以显式指定，也可以省略。如果省略，编译器会根据函数体中的返回语句自动推导返回类型 function_body：函数体，包含 lambda 表达式的实际代码。 哈希冲突的解决方法 线性探测 使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位 开链 每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中 再散列 发生冲突时使用另一种hash函数再计算一个地址，直到不冲突 二次探测 使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测","categories":[{"name":"后端","slug":"后端","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C++总结","slug":"后端/C-总结","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"STL体系结构","slug":"STL体系结构","date":"2023-11-08T03:08:20.000Z","updated":"2023-11-08T03:28:22.810Z","comments":true,"path":"2023/11/08/STL体系结构/","permalink":"https://lyfu0814.github.io/2023/11/08/STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"STL六大部件（component） 容器（containers）、分配器（allocators）、算法（algorithms）、 迭代器（iterators）、适配器（adapters）、仿函数（functors）； 数据在容器（内存的事情我们不必管，由分配器支持），处理数据在算法，连接之间的桥梁是迭代器（泛化的指针）。仿函数可以处理类之间的一些操作，适配器转换。 示例 123456789101112131415int stl_component()&#123; int ia[6] = &#123;27, 210, 12, 47, 109, 83&#125;; //用到了容器和分配器定义一个vector vector &lt;int, allocator&lt;int&gt; &gt; vi(ia, ia+6); //用到了算法，迭代器，函数适配器，函数对象 // vi.begin()和vi.end()迭代指向vi中的元素 // not1是negator，否定less的作用，变成了大于等于40的数 // bind2nd绑定了less比较的第二个对象，固定在40 cout &lt;&lt; count_if(vi.begin(), vi.end(), not1(bind2nd(less&lt;int&gt;(), 40))) &lt;&lt; endl; return 0; &#125; 分配器*不建议单独使用分配器； operator new()和底层的内存分配函数malloc() malloc()分配给申请内存大小的空间时会有额外的空间开销，如cookie、pad等； 一般使用时由于申请的size不大，所以这些额外的空间占的比例比较大，为缺陷； 分配器allocator的使用：用来分配内存 allocate()申请内存，调用::operator new()完成； deallocate()回收内存，调用::operator delete()完成； STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下： new运算分两个阶段：(1)调用allocate()配置内存;(2)调用对象构造函数construct() 构造对象内容 ； delete运算分两个阶段：(1)调用对象析构函数destroy() ；(2)调用deallocate()释放内存 为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，STL采用了两级配置器： 当分配的空间大小超过128字节时，会使用第一级空间配置器：直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放 当分配的空间大小小于128字节时，将使用第二级空间配置器：采用了内存池技术，维护16个list，通过空闲链表来管理内存。 为自由链表的管理，把需求的内存块自动提升为8的倍数，造成内部碎片； 释放后的内存块仍挂在自由链表上，不会还给操作系统。 容器 容器之间的关联不是继承，是复合关系，即会拥有某些容器的功能 vector 连续存储的容器，动态数组，在堆上分配空间 底层实现：数组 扩容：请求重新分配2倍大小的空间,然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效 适用场景：经常随机访问，且不经常对非尾节点进行插入删除 释放内存：erase和clear都不会释放内存，可以使用swap(vec)释放或清空全部内存； 删除元素：采用remove一般情况下不会改变容器的大小，而pop_back()与erase()等成员函数会改变容器的大小。 size得到有效元素个数，capacity得到空间容量； &#x3D;&#x3D;vector为什么是1.5或者是2倍扩容？&#x3D;&#x3D; 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。 采用成倍方式扩容可保证常数的复杂度，而增加指定大小的容量只能达到O(n)的复杂度（因为每次超出都会扩容1个元素） 以2倍的方式扩容，导致下一次申请的内存必然大于已释放的之前分配的内存总和，导致之前分配的内存不能再被使用 eg：如分配1，2，4，8，第四次需要8，但是前三次加起来才只有7 增长因子设置为(1,2)之间，多次扩容之后就可以复用之前释放的空间 如果倍数超过2倍(包含2)方式扩容会存在：空间浪费较高、无法使用之前释放的内存的问题 forward_list 动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间 底层：双向链表list &#x3D;&#x3D;vector和list的区别&#x3D;&#x3D; 1）vector底层实现是数组；list是双向链表。2）vector支持随机访问，list不支持。3）vector是顺序内存，list不是。4）vector在中间节点进行插入删除会导致内存拷贝，list不会。 5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好 vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。 list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。 &#x3D;&#x3D;resize()和reserve()&#x3D;&#x3D; resize()改变当前容器内含有元素的数量(size())，eg:v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；如果len比当前数目小，vector进行容量压缩，长度压缩到len大小，超出的元素进行销毁。reserve()（可以避免动态扩容）改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存； array 把array包装成容器，然后利用指针当iterator进行操作 deque：双向队列 deque在上层调用时表现是连续的，但是底层实现是用动态分段连续的buffer来实现的 deque可以实现空间（内存）动态缩小 通过迭代器（deque自己有iterator类）和操作符重载来营造连续插入或弹出的假象 一个迭代器内部有四个指针：cur, first, last, node，其中前三个指针是针对buffer而言的，而node指的是当前deque中用到了哪个buffer queue和stack 称queue和stack为容器适配器 利用deque模拟队列queue（用deque模拟stack同理）：内含一个deque并封锁某些功能 stack或queue都不允许遍历，也不提供iterator queue和stack的底层结构：可用list模拟，但是默认是deque，因为速度较快，queue不可选择vector做底层结构（因为vector没有pop_front()），stack可以选择vector做底层结构；stack和queue都不可以选择set或map作为底层结构。 红黑树（set、map） 红黑树是关联式查找容器的底层支撑结构之一 set和的底层利用Rb_tree实现，因此也是一种容器适配器； map和multimap使用红黑树实现key-data的存储，不允许改变key，但却可以改变值； &#x3D;&#x3D;map和set的区别，实现方式&#x3D;&#x3D; map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree） 区别 （1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。（2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。（3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。 &#x3D;&#x3D;map中[]与find的区别？&#x3D;&#x3D; map的下标运算符[]：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。 map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。 哈希表（unordered_set、unordered_map） hash table利用bucket（属于vector）和list（自定义的linked-list）来存储数据； hash function及hash code：hash function的目的：根据元素值计算出hash code，使得元素经映射之后能够足够随机，因为再被放入hush表中时，越随机越不容易发生碰撞； 利用hash table实现unordered_set, unordered_multiset, unordered_map, unordered_multimap容器； hash table使用拉链法解决hush冲突 bucket的数量：内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。 &#x3D;&#x3D;map与unordered_map的优缺点&#x3D;&#x3D; 对于map，其底层是基于红黑树实现的 优点如下：1)有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作2)map的查找、删除、增加等一系列操作时间复杂度稳定，都为$logn$缺点如下：1）查找、删除、增加等操作平均时间复杂度较慢，与n相关 对于unordered_map来说，其底层是一个哈希表 优点如下：查找、删除、添加的速度快，时间复杂度为常数级O(c)缺点如下：因为unordered_map内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高 Unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。极端情况下可能为O(n) priority_queue 在插入元素时，会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面 默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。 priority_queue的这种实现机制导致其不被归为容器，而是一种容器适配器 迭代器 算法通过迭代器连通容器，进行数据处理和函数运行 从语言层面上讲，容器是class template, 而算法是function template 有些算法还可传入定制的准则criterion, 比如sort函数的比较函数 五种迭代器 随机存取迭代器：random_access_iterator_tag (array, vector, deque)； 双向迭代器：bidirectional_iterator_tag(list, rb_tree)； 单向迭代器：forward_iterator_tag(forward_list, hashtable可能是，要看hashtable桶中的链表是单向还是双向) ； 多出来的两种input_iterator_tag和output_iterator_tag属于istream和ostream；五种之间是继承关系，同时用这种tag的方式，非简单的12345； 迭代器分类对算法的影响 算法的效率与算法能否判断迭代器的分类有很大关系 difference()函数：根据不同的迭代器类别计算其距离 copy()函数：根据迭代器的类型，所能做了很多的分支，优化到最快 &#x3D;&#x3D;迭代器删除元素（迭代器失效的情况）&#x3D;&#x3D; 序列容器：（vector,deque等） 使用erase(itertor)后，后边的每个元素的迭代器都会失效； 后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器； 关联容器：（map,set等） 使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。 list 使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。 &#x3D;&#x3D;迭代器和指针&#x3D;&#x3D; Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 迭代器和指针的区别 迭代器不是指针，是类模板，表现的像指针。 他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等。 &#x3D;&#x3D;迭代器++i，i++哪个更好，为什么？&#x3D;&#x3D; 在 C++ 中，迭代器 ++i（前置自增）和 i++（后置自增）都可以用于遍历容器中的元素。在某些情况下，++i 是一个更好的选择，原因如下： 性能优势： 前置自增 ++i 直接将迭代器的值加 1，然后返回自增后的迭代器。而后置自增 i++ 需要在自增之前创建并返回一个临时迭代器副本，然后再将原始迭代器的值加 1。 算法 C++标准库的函数与C函数在形式上有些不同，是一种函数模板，并且与迭代器联系紧密 举例 accumulate、for_each、replace，replace_if，replace_copy、count，count_if、find，find_if、sort、binary_search 仿函数 仿函数其实就是一个类似函数的对象（函数对象），必须重载函数调用运算符，只为算法服务 标准库规定可适配的仿函数都继承了二元变量操作binary_function或一元变量操作unary_function； 可适配的含义：可修改，可调整； 适配器 适配器用来修改一个既有的东西，如接口、参数个数、函数的名称等，但不改变这个东西的类型也不改变返回类型，即：仿函数适配器还是一个仿函数的样子； 适配器可以认为具有桥梁作用：把某个底层B包装下做成A交给用户使用，但是内部仍然是调用B来运作，在C++中，适配器采用复合（内含）的方式获得某种功能，非继承； 如：仿函数适配器中内含一个仿函数，容器适配器中内含一个容器 容器适配器 都内涵一个容器，默认为一个deque，如stack和queue 仿函数适配器 适配器修改了仿函数的部分功能，但最终还体现为一个仿函数，因此可以继续嵌套适配器； 123//介绍了前面使用过的一个计数语句,其中用到了算法(count_if)，函数适配器(not1和bind2nd)和函数对象(less&lt;int&gt;())。 cout &lt;&lt; count_if(vi.begin(), vi.end(), not1(bind2nd(less&lt;int&gt;, 40))); not1； bind：binder1st, binder2nd这些函数都被bind函数取代，但是旧的函数依旧可以使用； since C++11； 可以绑定函数、函数对象&#x2F;仿函数、成员函数、类对象； _1、 _2…为占位符，表示第几个参数； bind可以制定一个模板参数，表示返回类型：bind&lt;int&gt;(fumc, _1, _2)，或者直接用auto即可； 迭代器适配器 reverse iterator：rbegin()和rend()； 逆向迭代器内含一个正向迭代器； 对逆向迭代器取值对应于正向迭代器退一格取值； inserter copy()本身必须有目标空间才能赋值； inserter配合copy函数，实现在foo中选定位置进行bar数组的安插，而不是原先的覆盖赋值搬移； inserter是一个辅助函数，负责类型推导，实际的insert_iterator通过**重载操作符&#x3D;**实现元素的insert动作； traits raits技法利用“内嵌型别“的编程技巧与编译器的template参数推导功能，增强C++未能提供的关于类型认证方面的能力。常用的有iterator_traits和type_traits。 iterator_traits方便的让外界获取：迭代器所指对象的类型、两个迭代器之间的距离、迭代器所指向的类型、迭代器所引用的类型。 type_traits关注类型的特性：如是否具备额默认构造函数、拷贝构造函数等。","categories":[{"name":"后端","slug":"后端","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C++总结","slug":"后端/C-总结","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"内存管理","slug":"内存管理","date":"2023-11-08T03:08:20.000Z","updated":"2023-11-08T03:30:11.135Z","comments":true,"path":"2023/11/08/内存管理/","permalink":"https://lyfu0814.github.io/2023/11/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"编译过程 预处理：将要包含(include)的文件插入原文件中、将宏定义展开、根据条件编译命令(#ifdef)选择要使用的代码，最后将这些代码输出到一个“.i”文件中等待进一步处理。 预编译过程不涉及实际代码的编译，预处理器只是对源代码文件进行必要的处理，以便后续的编译过程能够顺利进行。 1gcc -E -o main.i main.c 编译：将相应的高级语言代码映射到汇编语言，如把上面的”.i”文件“翻译”成汇编代码，输出到“.s”文件。 编译器会对源代码进行词法分析、语法分析、语义分析（类型检查、作用域检查等）、代码优化 1gcc -S -o main.s main.i 汇编：将汇编语言映射到机器码，在Linux系统上一般表现为ELF目标文件(OBJ文件)。 汇编器还会计算各种地址和指针值，生成静态数据和符号表等信息，以便在链接过程中使用 1gcc -c -o main.o main.s 链接：将汇编生成的一个或多个目标文件、以及库文件链接起来，最终生成可以在特定平台运行的可执行程序。 链接器负责解析和处理目标文件中的符号表，合并静态数据和代码，解决外部引用和重定位等问题。 1gcc -o main main.o 动态链接：使用动态链接库(*.so)进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行，动态链接生成的程序体积较小，但是必须依赖所需的动态库，否则无法执行。 静态链接：使用静态库(*.a)进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，不过静态链接生成的程序体积较大。 静态库和动态库 文件格式： 静态库：通常以 .lib（Windows）或 .a（Linux&#x2F;UNIX）为扩展名。 动态库：通常以 .dll（Windows）或 .so（Linux&#x2F;UNIX）为扩展名。 链接方式： 静态库：在链接时与程序代码直接链接，生成的可执行文件包含了库中所有需要的代码。因此，可执行文件较大，但不需要额外的库文件。 动态库：在编译时不直接链接到程序中，而是在程序运行时动态链接。生成的可执行文件不包含库中的代码，只包含对库的引用。因此，可执行文件较小，但需要库文件才能运行。 代码重用与更新 静态库：如果多个程序使用同一个静态库，每个程序都会包含库的一份拷贝。这可能导致内存和磁盘空间的浪费。另外，当静态库更新时，需要重新编译所有使用它的程序。 动态库：多个程序可以共享同一份动态库，节省内存和磁盘空间。当动态库更新时，只需替换库文件，而不需要重新编译所有使用它的程序。但需要确保新版本的库与已有程序兼容。 程序加载时间 静态库：因为所有库代码都已链接到可执行文件，程序加载时间相对较短。 动态库：程序在运行时需要加载和链接动态库，这可能导致程序启动时间稍长。 跨平台兼容性 静态库：在不同平台间迁移时，可能需要重新编译静态库以确保兼容性。 动态库：更容易在不同平台间迁移，只需针对目标平台提供相应的动态库版本。 生成方式： 静态库：编译源文件为目标（.o）文件，使用 ar 命令将目标文件打包为静态库 动态库：编译源文件时，添加 -fPIC 标志来生成位置无关代码，使用 -shared 标志将目标文件链接为动态库 使用方式： 静态库：需要在编译命令行中链接，例如库的名称是libmylib.a，则使用-lmylib 1g++ main.cpp -o main -L/path/lib -lmylib 动态库：在运行时被加载到内存中。因此在运行程序时需要确保动态库在系统的库搜索路径中。 1export LD_LIBRARY_PATH=/path/lib:$LD_LIBRARY_PATH &#x3D;&#x3D;动态库的优缺点？&#x3D;&#x3D; 优点：代码重用、内存占用、更新简便、模块化、程序更具跨平台兼容性 缺点：链接开销、程序依赖、安全风险、版本许可问题、调试困难 预编译指令预处理器可以识别以 # 开头的指令。以下是一些常见的 C++ 预处理指令： #include用于包含其他头文件。 #define定义宏。用于定义常量或简单的函数。 #undef：取消宏定义。移除先前使用 #define 定义的宏。 #ifdef、#ifndef、#if、#elif、#else 和 #endif：条件编译指令。根据条件包含或排除代码。 #error：生成编译时错误。当预处理器遇到 #error 指令时，会中止编译并显示指定的错误消息。 #pragma：编译器特定指令。用于向编译器发送特殊的命令。 #include &lt;&gt;表示从系统目录下开始搜索，然后再搜索PATH环境变量所列出的目录，不搜索当前目录 &quot;&quot;表示先从当前目录搜索，然后是系统目录和PATH环境变量所列出的目录下搜索 条件编译指令（#ifdef，#ifndef） 通常用于头文件中的“包含保护”（include guard）机制。可以避免头文件在同一个编译单元中被多次包含，从而防止重复声明、编译错误和不必要的编译开销。 1234567// my_header.h#ifndef MY_HEADER_H#define MY_HEADER_H// 头文件的内容，如类声明、函数声明等#endif // MY_HEADER_H #ifndef指令检查一个名为MY_HEADER_H的宏是否已经定义。如果该宏尚未定义，预处理器将继续处理头文件的内容，并使用#define指令定义该宏。在头文件的末尾，#endif指令结束了包含保护。 如果头文件被多次包含，#ifndef指令将检测到MY_HEADER_H已经被定义，从而跳过头文件的内容，直接到达#endif指令。这样一来，同一个头文件在同一个编译单元中不会被多次包含，从而避免了重复声明和其他相关问题。 define、inline、typedefdefine和inline都可以用于定义简短的函数。 define define是C和C++中的预处理器指令，用于定义宏（macro）。 使用define定义的宏在预处理阶段进行文本替换，而不是在编译阶段进行处理。 宏没有作用域，它们在整个源文件中都是可见的 宏不进行类型检查，容易导致潜在的错误和难以调试的问题。 &#x3D;&#x3D;宏的优缺点&#x3D;&#x3D; 优点： 提高代码重用性：宏允许定义一段代码或文本，然后在多个地方使用。这有助于减少重复代码和提高代码可维护性。 提高性能：宏在编译阶段进行替换，因此可以避免函数调用带来的性能开销。 提高编译时配置灵活性：宏可以在编译时进行条件编译，有助于控制不同编译配置下的代码生成。 缺点： 可读性和维护性：宏的使用可能导致代码可读性降低，因为宏并不遵循常规的编程语法。 调试困难：由于宏在编译阶段进行替换，因此在调试过程中，宏替换后的代码可能会导致找出错误变得更加困难。 命名冲突：宏的命名空间是全局的，这可能导致命名冲突。如果在不同的头文件或源文件中定义了相同名称的宏，可能会引发意外的替换和编译错误。 类型不安全、没有作用域限制 inline inline是C++中的一个关键字，用于建议编译器将函数声明为内联函数。 内联函数在编译过程中可能被编译器直接插入到调用处，从而减少函数调用的开销。但请注意，编译器并不一定会接受这个建议，内联决策仍然由编译器自主决定。 内联函数具有作用域和类型检查，比宏更安全、更健壮。 typedef 用于定义类型别名 发生在编译过程中； typedef会进行数据类型检查； typedef是语句，要加分号标识结束；宏不是语句，不在在最后加分号 命名空间 作用： 避免名称冲突：以将一组相关的类、函数和变量等组织在一起，使它们与其他名字空间中的实体互相隔离，从而避免名称冲突。 代码组织结构化：将相关代码逻辑组织在一起，使代码更加结构化，便于阅读和维护。 使用： 使用using关键字引入命名空间内的特定实体：using my_namespace::MyClass; 使用using namespace my_namespace 指令将整个名字空间导入到当前作用域 变量所占字节数 变量 64位 32位 char 1byte 1byte char* 8byte 4byte short int 2byte 2byte int 4byte 4byte unsigned int 4byte 4byte float 4byte 4byte double 8byte 8byte long 8byte 4byte long long 8byte 8byte long long 8byte 4byte extern“C”extern &quot;C&quot;是一个链接指定符，用于告诉C++编译器在链接时如何处理被声明的函数或变量。它的主要目的是实现C和C++之间的互操作性。 C++支持函数重载（在同一个作用域内使用相同的函数名，但参数列表不同）。因此C++编译器在生成目标代码时会对函数名进行名字修饰（区分函数重载、不同命名空间的同名函数、不同类的成员函数等），以便在链接时区分具有相同名称的不同函数。这个过程通常会使得函数名更长，增加一些编译器特定的字符和编码。 C编译器并不支持函数重载，也不对函数名进行名字修饰。因此，当试图在C++中调用C函数或在C代码中调用C++函数时，可能会出现链接错误，因为链接器找不到正确的符号。 当在C++代码中使用extern &quot;C&quot;声明一个函数或变量时，C++编译器会禁用名字修饰，使得函数或变量的名字与C编译器生成的名字相同。这样，在链接时就可以正确地找到符号，实现C和C++之间的互操作性。 C++中的符号重复定义问题 问题发生情况： 同一个文件中重复定义了同名的全局变量、函数或类。 不同文件中定义了同名的全局变量、函数或类。 静态库中存在重复的符号。 链接了重复的目标文件。 解决方法： 使用#ifndef&#x2F;#define&#x2F;#endif的方式避免头文件被重复包含。 使用namespace来避免命名冲突：每个文件中的变量放在自己的namespace中。 用static关键字将变量、函数声明为文件作用域内的局部符号。 将全局变量或函数定义改为声明，将定义放在一个单独的源文件中。 &#x3D;&#x3D;编译器如何处理函数重载？&#x3D;&#x3D; 重载解析（Overload Resolution）： 当在同一作用域内存在多个同名函数时，编译器需要根据调用点的参数类型和数量来确定调用哪个函数。 名字修饰（Name Mangling）： 重载解析确定了要调用哪个函数之后，编译器需要为这些重载函数生成独特的二进制符号名。 编译错误与运行时错误 编译错误发生在编译阶段，通常是由于程序员编写的源代码不符合编程语言的规则。编译器在编译过程中会检测并报告这些错误。 如语法错误、类型不匹配、未定义的变量或函数等。 运行时错误发生在程序执行阶段，通常是由于程序逻辑错误、资源限制或外部输入导致的。 常见的运行时错误包括除以零、数组越界、空指针解引用、内存泄漏等。 文件组织 源文件和头文件的组织： 头文件（.h或.hpp）：通常包含类声明、函数声明、常量定义、模板定义等。头文件主要用于声明接口，它告诉编译器有关这些实体的基本信息，但不包含实现细节。 源文件（.cpp）：包含类方法的定义、函数的定义、全局变量的定义等。源文件提供了实现细节，它们与头文件中的声明相匹配。 编译： 对于每个源文件，编译器会单独进行编译，生成一个与源文件对应的目标文件","categories":[{"name":"后端","slug":"后端","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C++总结","slug":"后端/C-总结","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"标准库","slug":"标准库","date":"2023-11-08T03:08:20.000Z","updated":"2023-11-08T03:29:41.121Z","comments":true,"path":"2023/11/08/标准库/","permalink":"https://lyfu0814.github.io/2023/11/08/%E6%A0%87%E5%87%86%E5%BA%93/","excerpt":"","text":"IO类 IO类 头文件：iostream、fstream、sstream C++不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO，这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等； IO对象不能拷贝或赋值，也不能将形参或返回类型设置为流类型 代码通常应该在使用一个流之前检查它是否处于良好状态 1while (cin &gt;&gt; word); 管理输出缓冲：有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作 123cout &lt;&lt; &quot;hi!&quot; &lt;&lt; endl; // 输出内容和一个换行，然后刷新缓冲区cout &lt;&lt; &quot;hi!&quot; &lt;&lt; flush; // 输出内容，然后刷新缓冲区cout &lt;&lt; &quot;hi!&quot; &lt;&lt; ends &lt;&lt; 1; // 输出内容和一个空字符，然后刷新缓冲区。 &#x3D;&#x3D;cout和printf有什么区别？&#x3D;&#x3D; cout cout&lt;&lt;是类std::ostream的全局对象 其后可以跟不同的类型，因为cout&lt;&lt;已存在针对各种类型数据做了重载，更加智能和安全 cout有缓冲输出，flush立即强迫缓冲输出，endl换行再强迫缓冲输出； printf printf 是C标准库函数 printf是行缓冲输出，不是无缓冲输出 关联输入和输出流 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标椎库将cout和cin关联在一起 istream和ostream类型的tie成员都只能接收ostream *类型参数 文件输入输出：ifstream；ofstream；fstream 用IO运算符（&lt;&lt;和&gt;&gt;）来读写文件 用getline从一个ifstream读取数据 自动构造和析构：当一个fstream对象被销毁时，close会自动被调用 成员函数open和close：如果定义了一个空文件流对象，可以随后调用open来将它与文件关联起来，首先必须关闭已经关联的文件 string流：istringstream、ostringstream、stringstream 顺序容器 标准库中的顺序容器：vector、deque、list、forward_list、array、string &#x3D;&#x3D;string与C语言中的 char *有什么区别吗？它是如何实现的？&#x3D;&#x3D; string继承自basic_string,其实是对char进行了封装，封装的string包含了char数组，容量，长度等等属性。 string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间，然后将原字符串拷贝过去，并加上新增的内容。 关联容器泛型算法 大多数都独立于任何特定的容器，它们可用于不同类型的容器和不同类型的元素 算法不直接操作容器，而是遍历有两个迭代器指定的一个元素范围 算法可能改变容器中保存元素的值，也可能在容器内移动元素，但是永远不会直接添加或删除元素，也永远不会改变底层容器的大小，； 标准库定义了一类特殊的迭代器（插入器），给这类迭代器赋值会在底层的容器上执行插入操作 只读算法：find、count、accumulate、equal等 写容器元素的算法：fill、copy、replace等 重排容器元素的算法：sort+unique+erase 参数绑定：bind 优先使用成员函数版本的算法，而不是通用算法，因为代价太大。","categories":[{"name":"后端","slug":"后端","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C++总结","slug":"后端/C-总结","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"模板与泛型编程","slug":"模板与泛型编程","date":"2023-11-08T03:08:20.000Z","updated":"2023-11-08T03:30:04.775Z","comments":true,"path":"2023/11/08/模板与泛型编程/","permalink":"https://lyfu0814.github.io/2023/11/08/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/","excerpt":"","text":"在泛型编程中，在编译时就能获知类型； 模板是C++中泛型编程的基础，一个模板就是一个创建类或函数的蓝图或者公式。 标准库算法都是函数模板，标准库容器都是类模板。 函数模板 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 1234567template&lt;typename T&gt; int compare(const T &amp;v1,const T &amp;v2) &#123; if (v1 &lt; v2) return -1; if (v1 &gt; v2) return 1; return 0; &#125; 编译器使用推断出的模板参数来实例化出一个特定版本的函数 模板参数可以是模板类型或非模板类型 主要用于创建通用的、适用于多种数据类型的函数。常用于实现独立于类型的算法，如排序、查找等（std::sort 和 std::find）。 模板编译 当编译器遇到一个模板定义时，它并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 函数模板和类模板成员函数的定义通常放在头文件中 类模板 编译器不能为类模板推断模板参数类型，为了使用类模板（和我们以前使用模板一样），必须在模板名后的尖括号中提供用来代替模板参数的模板实参列表 1vector&lt;int&gt; vec; 当我们使用一个类模板时，必须提供额外信息即显式模板实参列表，它们被绑定到模板参数，编译器通过使用这些模板实参实例化出特定的类 主要用于创建具有通用数据成员和成员函数的类。通过参数化类型，模板类可以在多种类型之间复用相同的代码。常见的例子是容器类。 类模板的成员函数 可以在类模板内部也可以在类模板外部定义其成员函数，定义在类模板内的成员函数被隐式声明为内联函数 类模板成员函数的实例化：默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。 模板类的每个 static 数据成员必须有且仅有一个定义，但是，类模板的每个实例都有各自独享的 static 对象 模板参数 一个模板参数名的可用范围是其声明之后，至模板声明或定义结束之前； 模板参数会隐藏外层作用域中声明的相同名字； 与大多数其他上下文不同，在模板内不能重用模板参数名； 模板声明必须包含模板参数 使用类的类型成员 可以通过使用作用域运算符（::）来访问 static 成员和类型成员； 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型，因此若希望使用一个模板类型参数的类型成员，就必须显式使用 typename关键字告诉编译器该名字是一个类型而非 static 成员； 12345678template &lt;typename T&gt;typename T::value_type top(const T&amp; c)&#123; if(!c.empty()) return c.back(); else return typename T::value_type();//表示值初始化的一个变量&#125; 控制实例化 由于模板使用时才会进行实例化，如果在多个独立编译的源文件中都使用了相同的模板，并且提供了一样的模板参数时，每一个源文件就都会有一个该模板的实例造成额外开销。 解决办法，显式实例化，当编译器遇到extern声明时，它不会在本文件中生成实例化代码；将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）； 对于给定的一个实例化版本，可能有多个extern声明，但是必须只有一个定义 模板实参推断 编译器确定实例化哪个函数模板的过程，编译器检查使用模板参数的实参的类型，将这些类型或值绑定到模板参数，来自动实例化一个函数版本。 应用于函数模板的类型转换包括以下两项（对实参进行转换） const 转换：可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）实参 数组或函数指针转换：一个数组实参可以转换为一个指向其首元素的指针，一个函数实参可以转换为一个该函数类型的指针 其他类型转换，如算数转换、派生类向基类的转换、用户定义的转换，都不能应用于函数模板 如果函数参数类型不是模板参数，则对实参进行正常的类型转换 当一个模板类型参数用作多个函数形参的类型时，实参必须有相同的类型。如果推断出来的类型不匹配，调用是错误的； 1234567891011long lhg;compare(lng, 1024);//错误，不能实例化compare(long, int) //如果希望函数实参可以进行正常的类型转换，可以将函数模板定义为两个类型参数。template &lt;typename A, typename B&gt; int flexibleCompare(const A &amp;v1, const B &amp;v2) &#123; if...&#125; // 使用。long lng;flexibleCompare(lng, 1024);//使用的是flexibleCompare(long, int) 函数模板的显式实参：显式实例化 显式模板实参按由左至右的顺序与对应模板参数匹配，只有尾部（最右）参数的显式模板实参才可以忽略： 12345template &lt;typename T1, typename T2, typename T3&gt;T3 alternative_sum(T2,T1);// 此时我们必须为三个模板参数指定实参auto val3 = alternative_sum&lt;long long&gt;(i, lng);//错误，不能推断第三个模板参数auto val2 = alternative_sum&lt;long long, int, long&gt;(i, lng); 模板实参推断和引用 当一个函数参数是模板类型参数的一个普通（左值）引用时，只能传递一个左值（如一个变量或一个返回引用类型的表达式），实参可以是 const 类型也可以不是； 1234template &lt;typename T&gt; void f1(T&amp;);f1(i); //i 是一个 int；模板参数类型T是 intf1(ci); //ci 是一个 const int；模板参数T是 const intf1(5); //错误：实参必须是一个左值 若一个函数参数是 const T&amp;，可以传递任何类型实参（一个对象、一个临时对象或一个字面常量值），当函数参数本身是 const 时，T 的类型推断结果不会是一个 const 类型，因为 const 已经是函数类型的一部分 1234template &lt;typename T&gt; void f2(const T&amp;); f2(i); //i 是一个 int，模板参数 T 是 intf2(ci); //ci 是一个 const int，但模板参数 T 是 intf2(5); //一个 const &amp; 参数可以绑定到一个右值，T 是 int 当一个函数参数是一个右值引用时（即形如T&amp;&amp;），可以传递给他一个右值，类型推断过程类似普通左值引用函数参数的推断过程。 12template &lt;typename T&gt; void f3(T&amp;&amp;);f3(42); //实参是一个 int 类型的右值，模板参数 T 是 int 引用折叠和右值引用参数 当我们将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数时，编译器推断模板类型参数为实参的左值引用类型； 当我们间接创建一个引用的引用，则这些引用形成了折叠，即X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 都折叠成类型 X&amp;，类型X&amp;&amp; &amp;&amp; 折叠成 X&amp;&amp;； 注意： T&amp; ：只能传递左值； const T&amp; :可以传递任何类型； T&amp;&amp; ：可以传递左值或右值； （T&amp;&amp;是模板类的一种形式，它不是一个右值！） 模板类和模板函数的区别 实现目标 模板类：主要用于创建具有通用数据成员和成员函数的类。通过参数化类型，模板类可以在多种类型之间复用相同的代码。常见的例子是容器类，如 std::vector&lt;T&gt; 模板函数：主要用于创建通用的、适用于多种数据类型的函数。它们通常用于实现独立于类型的算法，如排序、查找等。例如，std::sort 和 std::find 都是模板函数。 定义方式 模板类使用 template 关键字和尖括号 &lt; &gt; 来定义类型参数。类型参数紧跟在 template 关键字之后，然后是类定义。 1234template &lt;typename T&gt;class MyClass &#123; // 类的成员定义&#125;; 模板函数：模板函数也使用 template 关键字和尖括号 &lt; &gt; 来定义类型参数。类型参数紧跟在 template 关键字之后，然后是函数定义。 1234template &lt;typename T&gt;T myFunction(T a, T b) &#123; // 函数实现&#125; 使用方式 模板类：在使用模板类时，需要为其指定类型参数。类型参数在类名之后的尖括号 &lt; &gt; 中提供。例如，std::vector&lt;int&gt; 表示一个存储 int 类型元素的向量。 模板函数：当调用模板函数时，通常无需显式指定类型参数。编译器会根据实际参数类型自动推导出相应的模板参数类型。 重载与函数模板 函数模板可以被另一个模板或一个普通非模板函数重载，名字相同的函数必须有不同数量或类型的参数； 匹配规则：如果恰有一个函数提供比任何其他函数更好的匹配，则选择此函数，但是，如果有多个函数提供同样好的匹配，则： 如果同样好的函数中只有一个是非模板函数，则选择此函数； 如果同样好的函数中没有非模板，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板； 否则，此调用有歧义。 可变参数模板 一个接受可变数目参数的模板函数或模板类，可变数目的参数被称为参数包，存在两种参数包： 模板参数包：表示零个或多个模板参数； 函数参数包，表示零个或多个函数参数； 1234567// Args是一个模板参数包，rest是一个函数参数包// Args表示零个或则多个模板参数列表// rest表示零个零个或者多个函数参数。template &lt;typename T, typename... Args&gt;void foo(const T &amp;t, const Args&amp;... rest);// 声明了foo是一个可变参数函数模板，它有一个名为T的的类型参数，和一个名为Args的模板参数包，这个包表示零个或者多个额外的类型参数。// foo函数参数列表包含一个const&amp;的参数，指向T类型，还包含一个名为rest的函数参数包。 可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身； 为了终止递归，还需要定义一个非可变参数的函数。 模板特例化 当我们不能（或者不希望）使用模板版本时，可以定义类或者函数模板的一个版本特例化。 当特例化一个函数模板时，必须为原模板中的每一个模板参数提供实参； 为了指出正在实例化一个模板，应该使用关键字 template 后跟一个空尖括号对（&lt;&gt;）,指出将为原模板所有模板参数提供实参。 12345678template&lt;typename T&gt; int compare(const T&amp;, const T&amp;);//compare 的特殊版本，处理字符数组的指针template&lt;&gt;int compare(const char* const &amp;p1, const char* const &amp;p2)&#123; return strcmp(p1, p2); &#125; 特例化的本质是实例化一个模板，而非重载，因此特例化不影响函数匹配； 类模板的特例化不必为所有模板参数提供实参，可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性； 我们只能部分特例化类模板，而不能部分特例化函数模板； 一个类模板的部分特例化本身也是一个模板，使用它的用户还必须为那么特例化中未指定的模板参数提供实参。 OOP vs. GP object-oriented programming and generic programming, 面对对象编程与泛型编程 OOP企图将data和methods放在一起; GP却将data和methods分开：算法通过迭代器操作容器数据;","categories":[{"name":"后端","slug":"后端","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C++总结","slug":"后端/C-总结","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"基本语言","slug":"基本语言","date":"2023-11-08T03:08:20.000Z","updated":"2023-11-08T03:29:17.929Z","comments":true,"path":"2023/11/08/基本语言/","permalink":"https://lyfu0814.github.io/2023/11/08/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E8%A8%80/","excerpt":"","text":"语言特点语言性质 面向对象编程（OOP）：允许用户定义类和对象，以及类的成员函数和数据成员。OOP的主要特性包括封装、继承和多态。 封装是一种将数据和操作数据的函数组合在一起的方法，这样可以隐藏对象的内部细节。封装可以提高代码的可读性和可维护性。 继承是一种允许从现有类派生出新类的方法，新类可以继承现有类的属性和方法，还可以添加新的属性和方法或者覆盖现有的方法。 多态是一种允许在程序中使用通用接口来处理不同类型的对象的方法。多态可以简化代码，提高代码的可扩展性和复用性。 泛型编程：C++支持模板，允许用户编写通用的代码，以处理不同类型的数据。模板可以用于创建通用的函数和类，从而实现类型无关的编程。 低级访问能力：C++允许用户直接操作内存和硬件，这使得C++成为一种高效且功能强大的语言，适用于底层编程和性能关键应用。 标准库：C++有一个丰富的标准库，提供了许多常用功能和数据结构，如容器、算法、输入&#x2F;输出操作、字符串处理等。 语言兼容性：C++与C语言具有很高的兼容性，这意味着大多数C程序可以在C++编译器中编译和运行。这使得C++可以轻松地与C语言代码集成。 RAII（资源获取即初始化，Resource Acquisition Is Initialization）：RAII是一种在C++中广泛使用的编程技巧，它将资源的分配和释放与对象的生命周期关联起来。这有助于防止资源泄漏和简化资源管理。 可以使用智能指针实现RAII 组成部分 核心语言、C++标准库、标准模板库（STL）。 异常处理 异常处理是通过一组特定的关键字和语法进行的。异常处理的主要目的是在程序运行过程中发生错误时提供一种优雅的处理和恢复机制。 C++通过使用try-catch块和标准异常类，可以确保程序在遇到问题时能够正常运行并提供有关错误的信息。 抛出异常（throw）：当检测到错误或异常情况时，可以使用throw关键字抛出一个异常。这可以是任何数据类型，比如整数、字符串或自定义类对象。 捕获异常（catch）：为了捕获和处理异常，需要使用try和catch块。try块包含可能引发异常的代码。catch块用于捕获异常并处理它。 标准异常类：C++标准库包含了一组异常类，这些类都继承自std::exception。一些常见的标准异常类包括std::runtime_error、std::invalid_argument、std::out_of_range等。 自定义异常类：如果需要创建自定义异常类型，可以通过继承std::exception或其子类来实现。 异常传播：当一个函数抛出一个异常，而该函数本身没有处理这个异常时，异常会向上传播至调用链上的上一级函数。如果没有任何函数捕获该异常，程序将终止并显示未捕获异常的错误信息。 提高C++性的方式 优化编译选项：使用编译器的优化选项，如 -O2 或 -O3，可以对生成的可执行文件进行优化。这些优化选项可能包括内联函数、循环展开、常量传播等。 选择合适的数据结构和算法：根据问题选择合适的数据结构和算法。合理使用STL容器和算法，如 vector、map、sort等。这可以显著提高程序效率。 避免不必要的内存分配：减少动态内存分配和释放的次数，使用对象池、预先分配内存、栈上分配内存等策略来减少内存碎片和提高性能。 利用缓存：尽量让数据局部性更强，减少缓存未命中。对于计算量大的操作，可以使用缓存技术来存储结果，避免重复计算。 并行计算：利用多核处理器、多线程、SIMD指令等并行计算技术，提高计算效率。使用C++11及更高版本的线程库、async、future等功能来实现多线程编程。 避免使用异常处理作为正常控制流：异常处理对性能有一定影响，应仅在真正需要时使用。尽量使用错误码或其他方法作为正常控制流。 使用内联函数和常量表达式：将小型函数声明为内联函数，以减少函数调用开销。使用constexpr关键字声明常量表达式，将在编译时计算值。 使用智能指针管理资源：避免内存泄漏，采用 RAII(Resource Acquisition Is Initialization) 技术，使用智能指针如 shared_ptr、unique_ptr 管理动态分配的资源。 变量定义和声明 变量声明： 变量声明向编译器表明了变量的类型和名称，但不分配内存。声明的目的是在编译时告诉编译器变量的存在，以便在其他地方使用它。变量可以在程序中声明多次，但只能定义一次。 变量定义： 变量定义既声明了变量，又为它分配了内存空间。定义同时还可以为变量指定初始值。变量在程序中只能定义一次，否则会导致编译错误。 全局变量和局部变量 全局变量 全局变量是在函数外部声明的变量，通常位于源文件的顶部。 全局变量在整个程序运行期间都是有效的，它们的作用范围是从声明处开始，直到程序结束。 全局变量可以在整个程序的任何地方访问，包括所有的函数和类。 全局变量在声明时具有默认初始值。例如，整数类型的全局变量默认初始化为0。 过多地使用全局变量可能导致代码的可维护性和可读性降低，因为它们可能在任何地方被访问和修改。因此，应谨慎使用全局变量。 局部变量 局部变量是在函数或代码块内声明的变量。 局部变量仅在声明它们的函数或代码块内部有效，离开这个范围后，它们就会被销毁。局部变量的作用范围仅限于声明它们的函数或代码块。 局部变量在声明时没有默认初始值，必须在使用之前对它们进行初始化。 局部变量有助于代码的封装和模块化，通常是编写可维护和可读代码的推荐方法。 extern关键字 用于声明全局变量或函数，表明它们的定义在其他地方（通常是另一个源文件）。这使得多个源文件可以共享同一个变量或函数，从而实现跨文件的代码组织和复用。 explicit关键字 explicit关键字用于修饰类的构造函数，以防止在某些情况下发生不希望的隐式类型转换。 默认情况下，如果一个构造函数只有一个参数，C++允许将该构造函数用于隐式类型转换。这可能导致意外的结果或难以发现的错误，使用explicit关键字可以禁止这种隐式类型转换，从而避免相关问题。 static关键字 主要用途： 隐藏：当static用于全局变量或函数时，它改变了变量或函数的可见性。静态的全局变量或函数仅在定义它们的源文件中可见，不会在其他源文件中产生冲突。 保持变量持久且唯一：当static用于局部变量时，它将变量的生命周期延长到整个程序执行期间。 静态类成员变量：当static用于类成员变量时，该成员变量被所有该类的对象共享，而不是为每个实例分配独立的存储空间。 静态类成员函数：当static用于类成员函数时，这个函数可以在不创建类的实例的情况下直接通过类名调用。静态成员函数没有this指针，因此它只能访问类的静态成员变量。 静态变量的初始化时机c与c++不同： 静态变量只会初始化一次，静态变量放在全局区域，所以在主程序之前就会为其分配内存。 对于c而言，c是在代码执行前，编译阶段分配好内存后，进行初始化。 对于c++而言，它是在执行相关代码时被初始化。 修饰全局或局部变量：静态变量 C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造。 全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。 局部静态变量作用域仍为局部作用域，当定义它的函数或者语句块结束时，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。 修饰普通函数：静态函数 在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。 修饰类的成员：类的静态成员和静态成员函数 静态成员：是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。 对象与对象之间的成员变量是相互独立的。要想共用数据，则需要使用静态成员和静态方法。 既可以通过类名来对静态成员变量进行引用，也可以通过对象名来对静态成员变量进行引用。因为只要在类中声明静态成员变量，即使不定义对象，也可以为静态成员变量分配空间，进而可以使用静态成员变量。 静态成员变量是在程序编译时分配空间，而在程序结束时释放空间。 初始化静态成员变量要在类的外面进行； 静态成员和普通成员 存储和生命周期 静态成员：静态成员变量在类的所有实例之间共享，因此只有一个存储空间分配给静态成员变量。静态成员变量的生命周期从程序开始执行时就开始，一直持续到程序结束。 普通成员：每个类的实例都有自己的一份普通成员变量。这意味着每创建一个类的实例，都会为其普通成员变量分配独立的存储空间。普通成员变量的生命周期与其所属的类实例相同。随类实例的销毁而销毁。 访问方式 静态成员：静态成员变量和静态成员函数可以通过类名直接访问，而不需要创建类的实例。同时，静态成员函数也可以通过类的实例访问，但它们没有this指针，因此无法访问非静态成员变量。 普通成员：普通成员变量和普通成员函数只能通过类的实例访问。它们可以访问类的所有成员（包括静态成员和非静态成员）。 初始化 静态成员：静态成员变量在程序启动之前的静态初始化阶段进行初始化。如果它们有显式的初始化器，则使用这些初始化器进行初始化；否则，它们将被初始化为零（整数类型）或者空（指针类型）。 普通成员：普通成员变量在创建类的实例时进行初始化。可以在构造函数中或使用成员初始化列表来初始化普通成员变量。 volatile关键字 防止编译器优化：编译器可能会对访问和修改变量的操作进行优化，例如将变量缓存在寄存器中或者删除对变量的多余访问。然而，这种优化可能导致程序行为不正确。volatile关键字确保编译器不会对这些变量进行不安全的优化，从而保持正确的程序行为。 内存访问顺序：volatile关键字可以确保对修饰的变量的访问按照程序代码的顺序执行。这在多线程环境或硬件访问中很重要，因为它们通常依赖于严格的顺序执行。 mutable关键字 如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const 1void add() const //在函数里不可修改this指针指向的值 被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中 左值和右值 左值和右值是表达式的属性 左值（lvalue）：在内存中占有确定位置的对象，有名字，可以取地址，可以出现在赋值号的左边或右边，当对象被用作左值时，用的是对象的身份（内存中的位置）。 右值（rvalue）：不在内存中占有确定位置的表达式，不能对其进行赋值，可以出现在赋值号的右边，但不能出现在赋值号的左边，当对象被用作右值时，用的是对象的值。 左值持久而右值短暂：右值要么是字面常量，要么是在表达式求值过程中创建的临时对象； 需要右值的地方可以用左值替代，反之则不行。 几种常见用到左值的运算符： 赋值运算符需要一个左值作为其左侧运算对象，得到的结果也是一个左值； 取地址符**&amp;**作用于一个左值对象，返回一个指向该运算对象的指针，这个指针是一个右值； 解引用符***、下标运算符[ ]**的求值结果都是左值； 内置类型和迭代器的递增递减运算符作用于左值对象，其前置版本所得的结果也是左值。 typedef 声明 可以使用 typedef 关键字为一个已有的类型取一个新的名字。 常量 对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局&#x2F;静态存储区。对于字面值常量，常量存放在常量存储区。 const限定符 const关键字用于表示常量性（constness），即某个对象或值在其生命周期内不能被修改。使用const关键字可以提高代码的可读性和安全性，因为它清楚地表明了哪些对象是不可变的，从而帮助我们避免意外地修改了不应该被修改的数据。 const对象必须初始化，一旦被初始化，其值就不能被修改。 默认状态下，const对象仅在文件内有效，如果想在文件间共享const对象，必须在变量的定义前添加extern关键字。 指针和引用：用于限制指针或引用所指向的对象的常量性。 const先修饰左边，左边没有就修饰右边。 const指针（* const） 把指针本身定为常量，常量指针（const pointer）必须初始化 1234int x = 42;int * const m = &amp;x //此时m是一个常量指针int a = 24;m = &amp;a; //编译错误 常量指针不能指向其他地址，但是指针所指向地址上保存的变量可以修改 指向常量的指针（const *） 要想存放常量对象的地址，只能使用指向常量的指针（pointer to const） 123int x = 42;const int* p = &amp;x; // 声明一个指向常量整数的指针int const* q = &amp;x; // 同上，声明一个指向常量整数的指针 指向常量的指针不能用于改变其所指对象的值，但该对象是否能改变依赖于所指对象的类型 指向常量的指针可以指向一个非常量对象 const的引用 可以把引用绑定到const对象上，称之为对常量的引用（reference to const）； 非常量引用不能绑定到常量对象上。 允许为一个常量引用绑定非常量的对象、字面值、甚至是一般表达式。 12int x = 42;const int&amp; r = x; // 声明一个指向常量整数的引用 成员函数：在类成员函数中，使用const关键字表示该成员函数不会修改类的任何非静态成员变量（除非它们被声明为mutable） 顶层const和底层const 顶层const表示对象本身是const，底层const表示指针所指的对象是const； 对一般对象，只有顶层const 对指针这种，本身是一个对象，又指向一个对象，故用顶层const表示指针是const，用底层const表示存放的地址为const（即指向的对象为const） 123const double *const pip = &amp;pi; // pip 是一个指向常量对象的常量指针// 第一个const：表明指针存放的地址为常量，即底层const，不能通过该指针修改所指对象的值；// 第二个const：表明指针为常量对象，即pip不能指向其他对象 对声明引用的const，都是底层const，因为引用本身不是对象，故不可能有顶层const 带const和不带const的两个函数可以同时存在，相当于函数重载。 constexpr和常量表达式 常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式；一个对象是不是常量表达式是由它的数据类型（要有const）和初始值（编译时就能得到结果）共同决定的； C++11规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式； 声明为constexpr的变量一定是一个常量，并且必须用常量表达式初始化。即如果认定变量是一个常量表达式，那就把它声明成constexpr类型 指针和引用都能定义为constexpr，但指针的初始值必须是nullptr或0或存储于某个固定地址中的对象 函数体内定义的变量一般存放在非固定地址，因此constexpr指针不能指向这样的变量 在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关 12const int *p = nullptr;//p是一个指向整型常量的指针cosntexpr int *q = nullptr;//q是一个指向整数的常量指针 &#x3D;&#x3D;const 和 #define 的区别？&#x3D;&#x3D; const 和 #define 都可以用于定义常量，但它们在C++中有一些重要的区别： 类型检查： const 是一个真正的常量，具有明确的数据类型，编译器会对其进行类型检查。而 #define 是预处理器的一部分，它不具备类型信息，不进行类型检查 调试友好： const 是编译器处理的，所以在调试时可以看到它的值和类型信息。但 #define 是预处理器处理的，在调试时不会显示宏的名称，可能导致调试困难。 作用域： const 变量具有确定的作用域，而 #define 宏定义没有作用域限制，除非使用 #undef 取消宏定义，否则宏将在整个编译单元内保持有效。这可能导致命名冲突 内存占用： const 变量会占用内存空间，因为它们是真正的变量。而 #define 宏只在编译时进行文本替换，不会分配内存空间。 使用场景： const 常量更适用于基本数据类型、指针和对象。而 #define 宏定义除了用于定义常量外，还可以用于定义条件编译指令、函数宏等。 class、union、structclass、union和struct都是C++中用于定义用户自定义类型的关键字。 class class用于定义类，可以包含数据成员和成员函数。 默认情况下，class的数据成员和成员函数是私有（private）的，只能通过类的成员函数进行访问和修改。 union union用于定义联合体，可以包含多个数据成员。 所有union的数据成员共享同一块内存空间，因此在同一时间只能存储一个数据成员的值。 默认情况下，union的数据成员是公共（public）的。 通常，union用于节省内存或实现底层数据操作。 在C++中，union可以包含构造函数、析构函数和其他成员函数，但这会使使用变得复杂。 struct struct用于定义结构体，可以包含数据成员和成员函数。 默认情况下，struct的数据成员和成员函数是公共（public）的。 在C++中，struct和class的功能几乎相同，只是默认的访问控制不同。struct通常用于表示简单的数据结构，而class用于实现面向对象编程的特性。 结构体可以有构造函数、析构函数以及其他特殊成员函数。 &#x3D;&#x3D;C++和C的struct区别&#x3D;&#x3D; C语言中：struct是用户自定义数据类型；C++中struct是抽象数据类型（ADT） C中struct是没有权限的设置，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数 C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容） 数据类型和类型转换怎样判断两个浮点数是否相等 在 C++ 中，直接使用等于运算符 == 来比较两个浮点数是否相等通常是不安全的，因为浮点数在计算机中的表示和计算可能会引入一定程度的误差。 可以定义一个足够小的容差值（epsilon），并比较两个浮点数的差值是否小于容差值 可以使用标准库中的 std::numeric_limits&lt;float&gt;::epsilon() 来获取机器的容差值 隐式转换 常见隐式转换 数组自动转换成指向数组首元素的指针。 当数组被用作decaltype的参数，或作为取地址符、sizeof等运算符的对象时，上述转换不会发生； 整数提升：将较小的整数类型（如 char 和 short）转换为较大的整数类型（如 int 或 long）。 算术转换：在算术表达式中将较低级别的算术类型转换为较高级别的算术类型。例如，将 float 转换为 double，或将 int 转换为 float。 转换为布尔类型：将算术类型、指针类型或类类型转换为布尔类型。 函数参数和返回值的隐式转换：当传递不同类型的实参给函数时，或者返回与函数声明中指定的返回类型不匹配的类型时，会发生隐式转换。 指针转换： 常量整数值0或字面值nullptr能转换成任意指针类型。 指向任意非常量的指针能转换为void *，指向任意对象的指针能转换为const void * 消除隐式转换的方法： 使用显式类型转换：通过使用 C++ 提供的显式类型转换操作符（如 static_cast、reinterpret_cast、const_cast 和 dynamic_cast）来指示需要进行的类型转换。 使用 C++11 引入的 explicit 关键字：在类构造函数或转换函数前添加 explicit 关键字，避免不必要的隐式类型转换，提高代码的可读性和安全性。 注意函数参数和返回值的类型：确保函数参数和返回值的类型与调用和实现时所使用的类型匹配，避免函数调用时发生意外的隐式类型转换。 使用类型别名或 auto 关键字：通过使用类型别名或 auto 关键字来推导类型，可以确保变量的类型与其初始化值相匹配，避免不必要的隐式类型转换。 四种显示转换 命名的强制类型转换：cast-name&lt;type&gt;(expression)； static_cast：最常用的类型转换运算符，用于在相关类型之间进行转换，例如整数和浮点数、指向基类和指向派生类的指针等。 只要不包含底层const，都可以用static_cast static_cast 在编译时完成转换，如果转换无法进行，编译器会报错 const_cast：只能改变运算对象的底层const，对于将常量对象转换成非常量的行为，称之为“去掉const性质”。 注意：使用 const_cast 去掉 const 属性后修改原本为常量的对象是未定义行为。 dynamic_cast：动态类型转换。只能用于含有虚函数的类，用于安全地在类的继承层次结构中进行指针或引用的转换（从基类到派生类）。 在进行向下转换时，dynamic_cast 会在运行时检查转换是否合法。 reinterpret_cast：几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用。 &#x3D;&#x3D;为什么不适用c语言的强制转换？&#x3D;&#x3D; C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 auto和decltype类型说明符auto 和 decltype 是 C++11 引入的两个类型推导关键字，它们用于在编译时根据表达式或变量的类型自动推导类型。 auto 关键字用于自动推导变量的类型。它可以根据变量的初始化表达式来推导变量的类型。使用 auto 时必须提供初始化表达式。 decltype： decltype 关键字用于根据表达式的类型推导出一个类型。与 auto 不同，decltype 不需要变量，它仅根据给定表达式的类型推导出相应的类型。 **decaltype((variable))的结果永远是引用（因为编译器会把（variable）当作一个表达式）；而dycaltype(variable)**结果只有当variable本身就是一个引用时才是引用。 null与nullptr区别NULL 和 nullptr 都是表示空指针的常量。 NULL NULL 在 C 和 C++ 中都可用，通常被定义为整数 0 或者类型为 void* 的空指针。 在 C++ 中，NULL 的确切类型取决于实现。它可以是一个整数，也可以是 void* 由于 NULL 可能是一个整数，它可能会导致类型推断和函数重载的问题。 nullptr nullptr 是 C++11 引入的新关键字，专门用于表示空指针。 nullptr 的类型是 std::nullptr_t，它可以隐式转换为任何指针类型，但不能隐式转换为整数类型。 使用 nullptr 可以避免 NULL 导致的类型推断和函数重载的问题。 指针和引用引用 引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。 引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。 引用就是C++对C语言的重要扩充。 左值引用和右值引用 左值和右值是表达式的属性，一般而言一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值 左值：能对表达式取地址、或具名对象&#x2F;变量。一般指表达式结束后依然存在的持久对象 右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。 左值引用： 左值引用是传统的C++引用，它绑定到左值上。 右值引用，就是绑定到右值的引用 通过 &amp;&amp; 而非 &amp; 来获得右值引用 绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期 右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。 右值引用主要用于实现移动语义和完美转发。 常规引用（左值引用）不能绑定到要求转换的表达式、字面常量或者返回右值的表达式，但右值引用有着完全相反的绑定特性，可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用绑定到一个左值上 123456int i = 42;int &amp;r = i; // 正确, r引用iint &amp;&amp;rr = i; // 错误, 不能将一个右值引用绑定到左值上int &amp;r2 = i * 42; // 错误: i * 42 是一个右值const int &amp;r3 = i * 42; // 正确： 我们可以将一个const的引用绑定到右值上int &amp;&amp;rr2 = i * 42; // 正确：将rr2绑定到右值上 std::move 和 std::forward std::move 用于将左值转换为右值引用，从而允许移动语义。移动语义可以提高性能，因为它允许编译器在某些情况下避免复制，如临时对象或不再需要的对象。当使用 std::move 时，通常意味着对象的所有权被转移，原对象可能处于搬移后的状态。 12std::vector&lt;int&gt; vec1 = &#123;1, 2, 3&#125;;std::vector&lt;int&gt; vec2 = std::move(vec1); // 移动 vec1 的内容到 vec2，避免复制 std::forward 用于实现完美转发，它是一种将参数的类型和值类别（左值或右值）原封不动地传递给另一个函数的技术。这在泛型编程和模板中非常有用，特别是当我们不知道参数的确切类型和值类别时。 指针 存放变量的地址，通过地址能找到所需的变量单元。 优先级：()&gt;[]&gt; *，即有括号就先看括号，然后是数组，然后是指针 &#x3D;&#x3D;区别以下指针类型&#x3D;&#x3D; 1234int *p[10]int (*p)[10]int *p(int)int (*p)(int) int *p[10]表示存放指针的数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。 int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。 int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。 int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。 引用和指针的区别 指针有自己的一块空间，而引用只是一个别名； 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小； 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用； 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象； 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变； 指针可以有多级指针（**p），而引用只有一级； 指针和引用使用++运算符的意义不一样； .如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露 。 指针和引用之间如何转换在C++中，指针和引用之间不能直接转换，因为它们在底层实现和使用方式上有本质区别。但是可以通过一些方法在它们之间进行间接转换。 从引用到指针的转换： 要将引用转换为指针，可以使用取址操作符（&amp;）来获取引用所指对象的地址。例如： 123int x = 10;int &amp;ref = x; // ref 是 x 的引用int *ptr = &amp;ref; // ptr 是指向 x 的指针 从指针到引用的转换： 要将指针转换为引用，可以使用解引用操作符（*）来获取指针所指向的对象。例如： 123int y = 20;int *ptr2 = &amp;y; // ptr2 是指向 y 的指针int &amp;ref2 = *ptr2; // ref2 是 y 的引用 智能指针 智能指针主要用于管理在堆上分配的内存，智能指针实际上就是一个类，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。 C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。 四个智能指针：auto_ptr, shared_ptr, weak_ptr, unique_ptr auto_ptr(c++98方案，c++11已经放弃） ，采用所有权模式。 unique_ptr(替换auto_ptr) ： 由于它不能被复制，只能被转移，因此保证同一时间内只有一个智能指针可以指向该对象。 unique_ptr在作用域结束时自动释放它所管理的内存，可以避免资源泄露（如“以new创建对象后因为发生异常而忘记调用delete” ） shared_ptr：实现共享式拥有，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。 成员函数： use_count 返回引用计数的个数 unique 返回是否是独占所有权( use_count 为 1) swap 交换两个 shared_ptr 对象(即交换所拥有的对象) reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr sp(new int(1)); sp 与 sp.get()是等价的 weak_ptr：不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象，它的构造和析构不会引起引用记数的增加或减少，是用来解决shared_ptr相互引用时的死锁问题。 不能通过weak_ptr直接访问对象的方法，应该先把它转化为shared_ptr。 智能指针内存泄漏问题 产生原因：当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。 解决方法：引入了weak_ptr弱指针，它的构造和析构不会引起引用记数的增加或减少，从而不会对对象的内存进行管理，其类似一个普通指针。 指针和数组的区别 指针 数组 保存数据的地址 保存数据 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 直接访问数据 通常用于动态的数据结构 通常用于固定数目且数据类型 相同的元素 通过Malloc分配内存，free释放内存 隐式的分配和删除 可以指向静态或动态分配的内存 内存是在声明数组时静态分配（栈或全局&#x2F;静态存储区） 使用 sizeof 运算符得到指针大小：4字节（32位机） 使用 sizeof 运算符计算数组的大小（字节数） 野指针和悬挂指针 野指针：指向无效内存区域的指针。 造成野指针的原因 指针变量没有被初始化（如果值不定，可以初始化为nullptr） 指针被free或者delete后，没有置为nullptr, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL。 指针操作超越了变量的作用范围，比如返回指向栈内存中局部变量的指针就是野指针。 如何避免野指针 初始化指针：在定义指针时，将其初始化为nullptr 使用智能指针自动管理内存：当智能指针的生命周期结束时，会自动释放指向的内存 在释放内存后将指针设为nullptr：使用delete释放内存后将原始指针设置为nullptr。这样可以防止对已释放内存的意外访问。 不要返回局部变量的地址：局部变量在函数返回后可能被销毁，因此指向它们的指针将成为野指针。 检查指针有效性：在使用指针之前，检查它们是否有效。例如，确保指针不是nullptr 谨慎使用指针算术：在进行指针运算时要特别小心，以避免意外访问无效内存地址。 悬挂指针：指针指向一个已经释放的地址空间。 函数指针 函数指针指向的是函数而不是对象 123// pf 指向一个函数，该函数的参数是两个const类型的引用，返回值是bool类型// 该函数的类型是 bool(const string&amp;, const string&amp;)。声明指向函数的指针，用指针替换函数名：bool (*pf)(const string &amp;, const string &amp;); // 未初始化 使用函数指针 当使用函数名作为一个值时，函数自动转换为指针 可以直接使用指向函数的指针调用该函数，无需解引用指针 在指向不同函数类型的指针之间不存在转换 函数指针形参：不能定义函数类型形参，但形参可以是指向函数的指针，当传入函数作为实参时，它将自动转换为指针 返回指向函数的指针：不能返回函数类型，但可以返回指向函数类型的指针，返回类型不会自动转换为指针，必须显式地将返回类型指定为指针类型 函数函数的定义和声明 定义 自动对象（automatic object）：只存在于块执行期间的对象，形参是自动对象。 局部静态对象（local static object）：在第一次执行经过对象定义前进行了初始化，函数结束时不会被销毁，在程序终止时被销毁，通过将局部变量定义为 static 来获得此类对象。 声明：函数只能定义一次，但可以声明多次，建议在头文件中声明，在源文件中定义。 参数传递 形参和实参 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此形参只在函数内部有效。 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。 当形参和实参不是指针类型时，在函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。 传值：通常会将输入的参数拷贝一份作为临时变量来操作，消耗一定的内存和时间。适用于基本数据类型（如 int、float、char 等）和较小的结构体。对于较大的数据结构（如大数组、大容器等），传值可能会导致性能下降。 传指针：将指针的副本传递给函数，函数接收到的是指向原始数据的指针 允许修改所指向的数据，但不允许修改指针本身 因为传递的是指针的副本，所以在函数内部修改指针不会影响到原始指针 指针可以为nullptr，这可能导致运行时错误。在使用指针之前，需要检查其有效性。 语法较为繁琐，需要使用指针操作符*和-&gt;来访问和修改数据。 传引用：将原始数据的别名传递给函数。函数接收到的是原始数据的引用，而不是副本 引用传递允许直接修改原始数据，无需额外的操作符 引用必须在创建时初始化，且不能重新绑定到其他对象。因此，引用通常比指针更安全 语法更简洁，无需使用特殊操作符。引用的使用与普通变量相似。 传引用通常适用于较大的数据结构，因为它只需要拷贝一个引用(本质就是一个地址)，无需对整个对象的复制，从而提高了效率。缺点是可能导致意外地修改原对象的值。 const形参和实参 传引用的潜在问题是可能导致意外地修改原变量，因此尽量使用常量引用作为形参； 当用实参初始化形参时会忽略掉顶层const，即当形参有顶层const时，传给形参常量对象或非常量对象都可以； 可以使用非常量初始化一个底层const对象，反之则不行。 数组形参：不允许拷贝数组，所以无法以值传递的方式使用数组形参，使用数组时通常会被转换成指针，所以当向函数传递一个数组时，实际上传递的是指向数组第一个元素的指针。 返回类型 可以返回临时变量，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存无关。 不要返回局部对象的引用或指针，因为函数返回时临时变量被销毁，导致指针指向一块无意义的地址空间。 调用一个返回引用的函数得到的是左值，其他返回类型得到右值。 因为数组不能被拷贝，所以函数不能返回数组，但可以返回数组的指针或引用。 主函数 main 的返回值：main 函数允许没有 return 语句直接结束，编译器会隐式插入 return 0。 内联函数和constexpr函数 内联函数：inline 函数避免函数调用的开销，通常旨在优化规模较小、流程直接、调用频繁的函数。 constexpr函数：可用于常量表达式的函数，return 类型和每个形参的类型必须是字面值类型，且函数主体必须有且只有一条 return 语句。 函数匹配 匹配顺序 精确匹配（实参和形参类型相同、实参从数组或函数转换成对应的指针、向实参添加顶层 const 或从实参中删除顶层 const） 通过 const 转换实现的匹配 通过类型提升实现的匹配 通过算术类型转换或指针转换实现的匹配 通过类类型转换实现的匹配 实现一个函数先于main函数运行 做法1：_attribute__((constructor)) 和 __attribute__((destructor)) 是GCC编译器提供的特殊属性，可以用此属性声明一个函数（返回值之后函数名之前），用于指定某个函数在程序启动之前（主函数main()执行之前）或退出之后（main()函数执行结束后）自动执行。 123void __attribute__((constructor)) init_function() &#123; std::cout &lt;&lt; &quot;Before main()&quot; &lt;&lt; std::endl;&#125; 做法2：在 C++ 中，可以使用全局对象的构造函数在 main 函数之前运行一些代码。应谨慎使用，因为全局对象的构造函数和析构函数的调用顺序可能受到编译器和链接器的影响。 &#x3D;&#x3D;在main执行之前和之后执行的代码可能是什么？&#x3D;&#x3D; main函数执行之前，主要就是初始化系统相关资源： 设置栈指针、初始化静态static变量和global全局变量、将未初始化部分的全局变量赋初值、全局对象初始化、将main函数的参数argc，argv等传递给main函数 main函数执行之后：全局对象的析构函数 标准库IO类 IO类 头文件：iostream、fstream、sstream C++不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO，这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等； IO对象不能拷贝或赋值，也不能将形参或返回类型设置为流类型 代码通常应该在使用一个流之前检查它是否处于良好状态 1while (cin &gt;&gt; word); 管理输出缓冲：有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作 123cout &lt;&lt; &quot;hi!&quot; &lt;&lt; endl; // 输出内容和一个换行，然后刷新缓冲区cout &lt;&lt; &quot;hi!&quot; &lt;&lt; flush; // 输出内容，然后刷新缓冲区cout &lt;&lt; &quot;hi!&quot; &lt;&lt; ends &lt;&lt; 1; // 输出内容和一个空字符，然后刷新缓冲区。 &#x3D;&#x3D;cout和printf有什么区别？&#x3D;&#x3D; cout cout&lt;&lt;是类std::ostream的全局对象 其后可以跟不同的类型，因为cout&lt;&lt;已存在针对各种类型数据做了重载，更加智能和安全 cout有缓冲输出，flush立即强迫缓冲输出，endl换行再强迫缓冲输出； printf printf 是C标准库函数 printf是行缓冲输出，不是无缓冲输出 关联输入和输出流 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标椎库将cout和cin关联在一起 istream和ostream类型的tie成员都只能接收ostream *类型参数 文件输入输出：ifstream；ofstream；fstream 用IO运算符（&lt;&lt;和&gt;&gt;）来读写文件 用getline从一个ifstream读取数据 自动构造和析构：当一个fstream对象被销毁时，close会自动被调用 成员函数open和close：如果定义了一个空文件流对象，可以随后调用open来将它与文件关联起来，首先必须关闭已经关联的文件 string流：istringstream、ostringstream、stringstream 顺序容器 标准库中的顺序容器：vector、deque、list、forward_list、array、string &#x3D;&#x3D;string与C语言中的 char *有什么区别吗？它是如何实现的？&#x3D;&#x3D; string继承自basic_string,其实是对char进行了封装，封装的string包含了char数组，容量，长度等等属性。 string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间，然后将原字符串拷贝过去，并加上新增的内容。 关联容器泛型算法 大多数都独立于任何特定的容器，它们可用于不同类型的容器和不同类型的元素 算法不直接操作容器，而是遍历有两个迭代器指定的一个元素范围 算法可能改变容器中保存元素的值，也可能在容器内移动元素，但是永远不会直接添加或删除元素，也永远不会改变底层容器的大小，； 标准库定义了一类特殊的迭代器（插入器），给这类迭代器赋值会在底层的容器上执行插入操作 只读算法：find、count、accumulate、equal等 写容器元素的算法：fill、copy、replace等 重排容器元素的算法：sort+unique+erase 参数绑定：bind 优先使用成员函数版本的算法，而不是通用算法，因为代价太大。","categories":[{"name":"后端","slug":"后端","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C++总结","slug":"后端/C-总结","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"类","slug":"类","date":"2023-11-08T03:08:20.000Z","updated":"2023-11-08T03:29:47.882Z","comments":true,"path":"2023/11/08/类/","permalink":"https://lyfu0814.github.io/2023/11/08/%E7%B1%BB/","excerpt":"","text":"类的基本思想是数据抽象和封装，数据抽象是一种依赖于接口和实现分离的编程技术，封装实现了该分离 类的接口包括用户所能执行的操作 类的实现则包括类的成员、负责接口实现的函数以及定义类所需要的各种私有函数 访问控制 访问说明符：加强类的封装性； 访问权限 类外部 派生类 类内部 public ✔ ✔ ✔ protected ❌ ✔ ✔ private ❌ ❌ ✔ 构造函数 构造函数 C++中的类需要定义与类名相同的特殊成员函数，叫做构造函数;构造函数可以在定义的时候有参数，构造函数没有任何返回类型。构造函数的调用: 一般情况下,C++编译器会自动调用构造函数，特殊情况下需要手工调用 列表初始化 成员的初始化顺序，与成员的声明顺序相同，与初始化列表的位置无关 初始化列表比构造函数先执行 必须使用列表初始化的场景 类存在继承关系，派生类必须在其初始化列表中调用基类的构造函数 初始化一个引用成员或常量成员 构造函数注意事项 类的数据成员不能在类的声明时候初始化，构造函数负责初始化类对象的数据成员； 类可以包含多个构造函数，不同的构造函数之间必须在参数数量或参数类型上有所区别； 构造函数不能被声明成const； 当类没有显式地定义构造函数，编译器会为隐式地定义一个默认构造函数； 通过将构造函数声明为explicit能抑制构造函数定义的隐式转换，只对一个实参的构造函数有效 &#x3D;&#x3D;为什么用成员初始化列表比赋值初始化会快一些？&#x3D;&#x3D; 赋值初始化，通过在函数体内进行赋值初始化 会产生临时对象，降低程序的效率 列表初始化，在冒号后使用初始化列表进行初始化 给数据成员分配内存空间时就进行初始化 &#x3D;&#x3D;为什么构造函数不能为虚函数？&#x3D;&#x3D; 存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针） vptr指针指向虚函数表，执行虚函数的时候，会调用vptr指针指向的虚函数的地址。 当定义一个对象的时候，首先会分配对象内存空间，然后调用构造函数来初始化对象。vptr变量是在构造函数中进行初始化的。又因为执行虚函数需要通过vptr指针来调用。如果可以定义构造函数为虚函数，那么就会陷入先有鸡还是先有蛋的循环讨论中。 &#x3D;&#x3D;C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？&#x3D;&#x3D; 将构造函数声明为 private 来阻止类被实例化。在以下情况会将构造函数声明为 private： 单例模式：单例模式是一种设计模式，用于确保一个类只有一个实例。构造函数（包括拷贝构造函数）和赋值运算符需要声明为 private，以防止外部代码创建类的多个实例。在这种情况下，类通常会提供一个公共的静态成员函数用于获取类的唯一实例。 工具类和静态成员函数类：有时可能需要创建一个工具类，该类只包含静态成员函数，而不需要创建对象。在这种情况下，可以将构造函数声明为 private，以防止类被实例化。这样可以确保类只用于调用静态成员函数，而不需要创建对象。 阻止派生类实例化：在某些情况下，希望一个类只能作为基类，而不能被实例化。这种情况下，可以将构造函数声明为 private 或 protected。这种情况更好的实现方法是声明为纯虚函数，即构造为抽象基类。 析构函数 析构函数：C++中的类可以定义一个特殊的成员函数清理对象析构函数没有参数和没有任何返回类型析构函数在对象销毁的时候自动调用析构函数调用机制: C++编译器自动调用 只能有一个析构函数，不能重载 如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数，如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数 如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。 类构造和析构的顺序 构造的顺序：基类构造函数-&gt;对象成员构造函数-&gt;派生类本身构造函数 析构的顺序：派生类本身的析构函数-&gt;对象成员析构函数-&gt;基类析构函数 &#x3D;&#x3D;为什么基类的析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？&#x3D;&#x3D; 如果父类的析构函数不是虚函数，则不会触发动态绑定（多态），结果就是只会调用父类的析构函数，而不会调用子类的析构函数，从而可能导致子类的内存泄漏（如果子类析构函数中存在free delete等释放内存操作时）； C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。 &#x3D;&#x3D;类什么时候会析构？&#x3D;&#x3D; 局部对象离开作用域 动态分配的对象被删除：如调用 delete 全局对象和静态对象的程序结束：全局对象和静态对象的生命周期与程序的生命周期相同，析构顺序可能是不确定的，这取决于编译器和链接器。 容器中的对象被移除 类成员对象的析构：当一个类对象包含其他类对象作为其成员时，包含的类对象会在外层类对象析构时一同被销毁。 拷贝控制 一个类通过定义五种特殊的成员函数来控制此类型对象拷贝、移动、赋值和销毁时做什么，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数 拷贝构造函数 一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造； 编译器也会在未定义时为合成一个拷贝构造函数 拷贝初始化发生的情况（拷贝初始化是依靠拷贝构造函数和移动构造函数完成的）： 用 &#x3D; 定义变量时会发生； 用类的一个实例化对象去初始化另一个对象； 将一个对象作为实参传递给一个非引用类型的形参； 从一个返回类型为非引用类型的函数返回一个对象； 用花括号列表初始化一个数组中的元素或一个聚合类中的成员； &#x3D;&#x3D;为什么拷贝构造函数必须传引用不能传值？&#x3D;&#x3D; 拷贝构造函数必须接受对象的引用而非对象本身，原因有两点： 无限递归问题： 如果拷贝构造函数接受一个对象作为参数（按值传递），则在拷贝构造函数被调用时，它需要创建一个新的对象。创建新对象时，会再次调用拷贝构造函数，这将导致无限递归调用。最终，程序会因栈溢出而崩溃。 效率问题： 按值传递对象时，需要调用拷贝构造函数创建临时对象。这会导致额外的开销，特别是在处理大型对象时。而按引用传递对象可以避免额外的拷贝操作，从而提高程序效率。 拷贝赋值运算符：接受一个与其所在类相同类型的参数 三&#x2F;五法则： 需要析构函数的类也需要拷贝和赋值操作； 需要拷贝操作的类也需要赋值操作，反之亦然； 析构函数不能是删除的； 如果一个类有删除的或不可访问的析构函数，那么其默认和拷贝构造函数会被定义为删除的； 如果一个类有const或引用成员，则不能使用合成的拷贝赋值操作； 所有五个拷贝控制成员应该看作一个整体。 使用&#x3D;default：通过将拷贝控制成员定义为&#x3D;default来显示的要求编译器生成合成的版本 阻止拷贝：对于某些类来说，拷贝构造函数和拷贝赋值运算符没有合理的意义，可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝，即在函数的参数列表后面加上 &#x3D;delete 来指出我们希望将它定义为删除的。 拷贝控制和资源管理 管理类外资源的类必须定义拷贝控制成员，这种类需要通过析构函数来释放对象所分配的资源，一旦一个类需要析构函数，则几乎肯定需要一个拷贝构造函数和一个拷贝赋值运算符； 在编写一个赋值运算符时，一个较好的模式是先将右侧运算符对象拷贝到一个局部临时对象中，当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。 对象移动 移动而非拷贝对象：直接调用标准库函数std::move(定义在utility头文件中) 使用移动而不是拷贝的原因： IO 类或者 unique_ptr &#x3D;这些类都包含不能被共享的资源(如指针或者IO缓冲)，因此这些类型的对象不能被拷贝但是可以被移动 在重新分配内存的过程中移动而不是拷贝元素 移动控制 为了让我们自己的类支持移动操作（窃取资源而不是拷贝资源），需要为其定义移动构造函数和移动赋值运算符； 移动构造函数 第一个参数是该类类型的右值引用，且任何额外的参数都必须有默认实参； 移动构造函数必须确保移后源对象必须不再指向被移动的资源，这些资源的所有权已经属于新创建的对象； 与拷贝构造函数不同，移动构造函数不分配任何新内存； 移动赋值运算符 移后源对象必须可析构：从一个对象移动数据并不会销毁对象，但有时在移动操作完成后，源对象会被销毁，必须确保移后源对象进入一个可析构的状态 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept（在类头文件的声明和定义中都进行指定） 合成的移动操作 只有一个类没有定义任何自己版本的拷贝控制成员，并且所有非static数据成员都可以移动时，编译器才会为它合成移动构造函数或者移动赋值运算符 &#x3D;&#x3D;C++的空类有哪些成员函数？大小是多少？&#x3D;&#x3D; 在C++中，空类（没有定义任何成员变量和成员函数的类）会自动获得一些隐式成员函数。编译器会为这个类生成以下特殊成员函数： 默认构造函数：如果没有提供其他构造函数，编译器将生成一个默认构造函数。 析构函数：用于在对象生命周期结束时清理资源。 拷贝构造函数：用于创建一个对象的副本。 拷贝赋值运算符：用于将一个对象的值赋给另一个对象。 移动构造函数（C++11）：用于从一个对象转移资源到另一个对象，无需创建副本。 移动赋值运算符（C++11）：用于将一个对象的资源移动到另一个对象。 这些成员函数在需要时才会被生成，例如当我们创建对象或执行相应的操作时。 尽管空类没有数据成员，但为了确保其对象具有独立的内存地址，编译器会分配至少1字节的空间。 重载 重载运算符应使用与内置类型一致的含义 通常情况下，不应该重载逗号，取地址，逻辑与和逻辑或运算符 选择作为成员或非成员： 赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）必须是成员函数； 复合赋值运算符（例如+=）一般来说应该是成员，但并非必须； 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员； 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数； 输入输出运算符必须是非成员函数，需要读写类的非公有数据成员时，IO运算符一般被声明为友元； 当把运算符定义为成员函数时，它的左侧运算对象必须是运算符所属类的一个对象 区分前置和后置运算符 普通的重载无法区分，前置和后置的区别，规定后置版本接受一个额外的（不被使用）int类型的形参，使用后置运算符时，编译器为这个形参提供一个值为0的实参。 标准库定义的函数对象 标准库定义了一组表示算术运算符、关系运算符、逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符 ​ 表示运算符的函数对象类常用来替换算法中的默认运算符 重载和重写 重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写","categories":[{"name":"后端","slug":"后端","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C++总结","slug":"后端/C-总结","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"编译过程及执行原理","slug":"编译过程及执行原理","date":"2023-11-08T03:08:20.000Z","updated":"2023-11-08T03:28:28.091Z","comments":true,"path":"2023/11/08/编译过程及执行原理/","permalink":"https://lyfu0814.github.io/2023/11/08/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/","excerpt":"","text":"编译过程 预处理：将要包含(include)的文件插入原文件中、将宏定义展开、根据条件编译命令(#ifdef)选择要使用的代码，最后将这些代码输出到一个“.i”文件中等待进一步处理。 预编译过程不涉及实际代码的编译，预处理器只是对源代码文件进行必要的处理，以便后续的编译过程能够顺利进行。 1gcc -E -o main.i main.c 编译：将相应的高级语言代码映射到汇编语言，如把上面的”.i”文件“翻译”成汇编代码，输出到“.s”文件。 编译器会对源代码进行词法分析、语法分析、语义分析（类型检查、作用域检查等）、代码优化 1gcc -S -o main.s main.i 汇编：将汇编语言映射到机器码，在Linux系统上一般表现为ELF目标文件(OBJ文件)。 汇编器还会计算各种地址和指针值，生成静态数据和符号表等信息，以便在链接过程中使用 1gcc -c -o main.o main.s 链接：将汇编生成的一个或多个目标文件、以及库文件链接起来，最终生成可以在特定平台运行的可执行程序。 链接器负责解析和处理目标文件中的符号表，合并静态数据和代码，解决外部引用和重定位等问题。 1gcc -o main main.o 动态链接：使用动态链接库(*.so)进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行，动态链接生成的程序体积较小，但是必须依赖所需的动态库，否则无法执行。 静态链接：使用静态库(*.a)进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，不过静态链接生成的程序体积较大。 静态库和动态库 文件格式： 静态库：通常以 .lib（Windows）或 .a（Linux&#x2F;UNIX）为扩展名。 动态库：通常以 .dll（Windows）或 .so（Linux&#x2F;UNIX）为扩展名。 链接方式： 静态库：在链接时与程序代码直接链接，生成的可执行文件包含了库中所有需要的代码。因此，可执行文件较大，但不需要额外的库文件。 动态库：在编译时不直接链接到程序中，而是在程序运行时动态链接。生成的可执行文件不包含库中的代码，只包含对库的引用。因此，可执行文件较小，但需要库文件才能运行。 代码重用与更新 静态库：如果多个程序使用同一个静态库，每个程序都会包含库的一份拷贝。这可能导致内存和磁盘空间的浪费。另外，当静态库更新时，需要重新编译所有使用它的程序。 动态库：多个程序可以共享同一份动态库，节省内存和磁盘空间。当动态库更新时，只需替换库文件，而不需要重新编译所有使用它的程序。但需要确保新版本的库与已有程序兼容。 程序加载时间 静态库：因为所有库代码都已链接到可执行文件，程序加载时间相对较短。 动态库：程序在运行时需要加载和链接动态库，这可能导致程序启动时间稍长。 跨平台兼容性 静态库：在不同平台间迁移时，可能需要重新编译静态库以确保兼容性。 动态库：更容易在不同平台间迁移，只需针对目标平台提供相应的动态库版本。 生成方式： 静态库：编译源文件为目标（.o）文件，使用 ar 命令将目标文件打包为静态库 动态库：编译源文件时，添加 -fPIC 标志来生成位置无关代码，使用 -shared 标志将目标文件链接为动态库 使用方式： 静态库：需要在编译命令行中链接，例如库的名称是libmylib.a，则使用-lmylib 1g++ main.cpp -o main -L/path/lib -lmylib 动态库：在运行时被加载到内存中。因此在运行程序时需要确保动态库在系统的库搜索路径中。 1export LD_LIBRARY_PATH=/path/lib:$LD_LIBRARY_PATH 动态库的优缺点？ 优点：代码重用、内存占用、更新简便、模块化、程序更具跨平台兼容性 缺点：链接开销、程序依赖、安全风险、版本许可问题、调试困难 预编译指令预处理器可以识别以 # 开头的指令。以下是一些常见的 C++ 预处理指令： #include用于包含其他头文件。 #define定义宏。用于定义常量或简单的函数。 #undef：取消宏定义。移除先前使用 #define 定义的宏。 #ifdef、#ifndef、#if、#elif、#else 和 #endif：条件编译指令。根据条件包含或排除代码。 #error：生成编译时错误。当预处理器遇到 #error 指令时，会中止编译并显示指定的错误消息。 #pragma：编译器特定指令。用于向编译器发送特殊的命令。 #include &lt;&gt;表示从系统目录下开始搜索，然后再搜索PATH环境变量所列出的目录，不搜索当前目录 &quot;&quot;表示先从当前目录搜索，然后是系统目录和PATH环境变量所列出的目录下搜索 条件编译指令（#ifdef，#ifndef） 通常用于头文件中的“包含保护”（include guard）机制。可以避免头文件在同一个编译单元中被多次包含，从而防止重复声明、编译错误和不必要的编译开销。 1234567// my_header.h#ifndef MY_HEADER_H#define MY_HEADER_H// 头文件的内容，如类声明、函数声明等#endif // MY_HEADER_H #ifndef指令检查一个名为MY_HEADER_H的宏是否已经定义。如果该宏尚未定义，预处理器将继续处理头文件的内容，并使用#define指令定义该宏。在头文件的末尾，#endif指令结束了包含保护。 如果头文件被多次包含，#ifndef指令将检测到MY_HEADER_H已经被定义，从而跳过头文件的内容，直接到达#endif指令。这样一来，同一个头文件在同一个编译单元中不会被多次包含，从而避免了重复声明和其他相关问题。 define、inline、typedefdefine和inline都可以用于定义简短的函数。 define define是C和C++中的预处理器指令，用于定义宏（macro）。 使用define定义的宏在预处理阶段进行文本替换，而不是在编译阶段进行处理。 宏没有作用域，它们在整个源文件中都是可见的 宏不进行类型检查，容易导致潜在的错误和难以调试的问题。 宏的优缺点？ 优点： 提高代码重用性：宏允许定义一段代码或文本，然后在多个地方使用。这有助于减少重复代码和提高代码可维护性。 提高性能：宏在编译阶段进行替换，因此可以避免函数调用带来的性能开销。 提高编译时配置灵活性：宏可以在编译时进行条件编译，有助于控制不同编译配置下的代码生成。 缺点： 可读性和维护性：宏的使用可能导致代码可读性降低，因为宏并不遵循常规的编程语法。 调试困难：由于宏在编译阶段进行替换，因此在调试过程中，宏替换后的代码可能会导致找出错误变得更加困难。 命名冲突：宏的命名空间是全局的，这可能导致命名冲突。如果在不同的头文件或源文件中定义了相同名称的宏，可能会引发意外的替换和编译错误。 类型不安全、没有作用域限制 inline inline是C++中的一个关键字，用于建议编译器将函数声明为内联函数。 内联函数在编译过程中可能被编译器直接插入到调用处，从而减少函数调用的开销。但请注意，编译器并不一定会接受这个建议，内联决策仍然由编译器自主决定。 内联函数具有作用域和类型检查，比宏更安全、更健壮。 typedef 用于定义类型别名 发生在编译过程中； typedef会进行数据类型检查； typedef是语句，要加分号标识结束；宏不是语句，不在在最后加分号 命名空间 作用： 避免名称冲突：以将一组相关的类、函数和变量等组织在一起，使它们与其他名字空间中的实体互相隔离，从而避免名称冲突。 代码组织结构化：将相关代码逻辑组织在一起，使代码更加结构化，便于阅读和维护。 使用： 使用using关键字引入命名空间内的特定实体：using my_namespace::MyClass; 使用using namespace my_namespace 指令将整个名字空间导入到当前作用域 变量所占字节数 变量 64位 32位 char 1byte 1byte char* 8byte 4byte short int 2byte 2byte int 4byte 4byte unsigned int 4byte 4byte float 4byte 4byte double 8byte 8byte long 8byte 4byte long long 8byte 8byte long long 8byte 4byte extern“C”extern &quot;C&quot;是一个链接指定符，用于告诉C++编译器在链接时如何处理被声明的函数或变量。它的主要目的是实现C和C++之间的互操作性。 C++支持函数重载（在同一个作用域内使用相同的函数名，但参数列表不同）。因此C++编译器在生成目标代码时会对函数名进行名字修饰（区分函数重载、不同命名空间的同名函数、不同类的成员函数等），以便在链接时区分具有相同名称的不同函数。这个过程通常会使得函数名更长，增加一些编译器特定的字符和编码。 C编译器并不支持函数重载，也不对函数名进行名字修饰。因此，当试图在C++中调用C函数或在C代码中调用C++函数时，可能会出现链接错误，因为链接器找不到正确的符号。 当在C++代码中使用extern &quot;C&quot;声明一个函数或变量时，C++编译器会禁用名字修饰，使得函数或变量的名字与C编译器生成的名字相同。这样，在链接时就可以正确地找到符号，实现C和C++之间的互操作性。 C++中的符号重复定义问题 问题发生情况： 同一个文件中重复定义了同名的全局变量、函数或类。 不同文件中定义了同名的全局变量、函数或类。 静态库中存在重复的符号。 链接了重复的目标文件。 解决方法： 使用#ifndef&#x2F;#define&#x2F;#endif的方式避免头文件被重复包含。 使用namespace来避免命名冲突：每个文件中的变量放在自己的namespace中。 用static关键字将变量、函数声明为文件作用域内的局部符号。 将全局变量或函数定义改为声明，将定义放在一个单独的源文件中。 编译器如何处理函数重载？ 重载解析（Overload Resolution）： 当在同一作用域内存在多个同名函数时，编译器需要根据调用点的参数类型和数量来确定调用哪个函数。 名字修饰（Name Mangling）： 重载解析确定了要调用哪个函数之后，编译器需要为这些重载函数生成独特的二进制符号名。 编译错误与运行时错误 编译错误发生在编译阶段，通常是由于程序员编写的源代码不符合编程语言的规则。编译器在编译过程中会检测并报告这些错误。 如语法错误、类型不匹配、未定义的变量或函数等。 运行时错误发生在程序执行阶段，通常是由于程序逻辑错误、资源限制或外部输入导致的。 常见的运行时错误包括除以零、数组越界、空指针解引用、内存泄漏等。 文件组织 源文件和头文件的组织： 头文件（.h或.hpp）：通常包含类声明、函数声明、常量定义、模板定义等。头文件主要用于声明接口，它告诉编译器有关这些实体的基本信息，但不包含实现细节。 源文件（.cpp）：包含类方法的定义、函数的定义、全局变量的定义等。源文件提供了实现细节，它们与头文件中的声明相匹配。 编译： 对于每个源文件，编译器会单独进行编译，生成一个与源文件对应的目标文件","categories":[{"name":"后端","slug":"后端","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C++总结","slug":"后端/C-总结","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"面向对象程序设计","slug":"面向对象程序设计","date":"2023-11-08T03:08:20.000Z","updated":"2023-11-08T03:29:55.536Z","comments":true,"path":"2023/11/08/面向对象程序设计/","permalink":"https://lyfu0814.github.io/2023/11/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"面向对象程序设计基于三个基本概念： 继承： 指子类可以继承父类的属性和方法。子类除了拥有父类的特性外，还可以具有自己特有的属性和方法。这种方式可以实现代码的重用和模块化，减少编写重复代码。继承有助于实现类之间的层次关系，有助于理解和维护代码结构。 封装： 将数据和操作数据的方法包装在一起，形成一个独立的“对象”。有助于降低系统的复杂性，提高可维护性。封装的主要目的是增强安全性，保护数据以免被外部代码随意访问和修改。为此，通常将对象的属性设为private或protected，并公共public方法来访问和修改这些属性。 多态： 允许不同类的对象对同一消息作出响应，即同一方法名可以在不同类中具有不同的实现。多态实现的主要方式有两种：接口实现和重写（覆盖）。 定义基类和派生类 定义基类 基类通常都应该定义一个虚析构函数，这样可以确保在删除基类指针指向的派生类对象时，派生类的析构函数能够被正确调用，避免内存泄漏等问题。 成员函数与继承： 基类希望其派生类进行覆盖的函数，通常将其定义为虚函数； 在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定； 任何构造函数之外的非静态函数都可以是虚函数； 关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义； 如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数； 成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。 定义派生类 派生类必须通过类派生列表明确指出它是从哪个基类继承而来 访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见：如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分； 派生类中的虚函数：派生类常覆盖继承的虚函数，若无覆盖则会直接继承其在基类中的版本； 派生类对象及派生类向基类的类型转换 一个派生类对象包含有派生类自己定义成员的子对象，以及其所继承的基类对应的子对象 派生类到基类的类型转换（编译器会隐式地执行）：可以将派生类的对象当成基类对象使用，也可以将基类指针或引用绑定到派生类对象中的基类部分 派生类构造函数： 每个类控制它自己的成员的初始化过程，因此派生类必须使用基类的构造函数来初始化它的基类部分 首先初始化基类的部分，然后按照声明的顺序依次初始化派生列的成员 继承与静态成员： 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例 假设某静态成员是可访问的，则既能通过基类使用它也能通过派生类使用它 被用作基类的类： 如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明 一个类不能派生它本身 最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象 防止继承发生的方法，即在类名后跟一个关键字final： 类型转换与继承 可以将基类的指针或引用绑定到派生类对象上 静态类型与动态类型 静态类型：对象被定义的类型或表达式产生的类型，静态类型在编译时是已知的 动态类型：对象在运行时的类型，引用所引对象或者指针所指对象的动态类型可能与该引用或指针的静态类型不同； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致 不存在从基类向派生类的隐式类型转换：一个基类对象可能是派生类对象的一部分，也可能不是，因此不存在从基类向派生类的自动类型转换 虚函数 当使用基类的引用或指针调用一个虚成员函数时，会执行动态绑定，对虚函数的调用可能在运行时才被解析 C++的多态性：具有继承关系的多个类型称为多态类型，引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在 声明虚函数：在基类中声明虚函数时，在成员函数声明之前加上关键字virtual 重写虚函数：派生类可以重写（Override）基类的虚函数，实现自己的版本。派生类中重写虚函数时，函数的签名（即返回类型、函数名和参数列表）必须与基类中的虚函数完全相同。 静态多态 静态多态：也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。静态多态有两种实现方式：函数重载：包括普通函数的重载和成员函数的重载函数模板的使用 动态多态 即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。通过虚函数和继承实现。通过基类类型的引用或者指针调用虚函数 &#x3D;&#x3D;vptr为什么不做成静态变量？&#x3D;&#x3D; 如果不考虑多态，vptr的值都是确定的，在编译时就可以确定，所以就不需要初始化 但是遇到多态就需要在其他地方保存动态信息并动态初始化vptr的值，不如直接动态初始化 final 和 override 说明符 override：派生类重写基类中的虚函数，如果使用 override 标记了某个函数，但该函数没有重写已存在的虚函数，此时编译器将会报错 还可以把某个函数指定为 final，则之后任何尝试覆盖该函数的操作都将引发错误 final 和 override 说明符出现在形参列表（包括任何 const 或引用修饰符）以及尾置返回类型之后 回避虚函数机制：在某些情况下，我们希望虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本，使用作用域运算符可以实现这一目的 虚函数的原理 虚函数的实现原理主要依赖于虚函数表和虚函数指针。 虚函数表（Vtable）： 当一个类中声明了虚函数时，编译器会为这个类生成一个虚函数表。虚函数表是一个存储类成员函数指针的数组。每个包含虚函数的类都有自己的虚函数表，其中包含了类的所有虚函数的地址。当派生类覆盖（Override）了基类的虚函数时，派生类的虚函数表中会使用派生类的函数地址替换基类的函数地址。 虚函数指针： 每个包含虚函数的类的对象都有一个隐藏的成员变量，即虚函数指针，通常称为vptr。对象的vptr指向其类的虚函数表。当我们通过基类指针或引用调用虚函数时，编译器会自动根据vptr找到相应的虚函数表，然后根据虚函数在虚函数表中的索引找到并调用相应的函数。这个过程发生在运行时，因此实现了多态。 &#x3D;&#x3D;虚函数可以声明为inline吗&#x3D;&#x3D; 虚函数可以声明为inline，但是将虚函数声明为inline的实际效果有限。inline函数是编译器在编译时将函数体直接插入到调用处的函数，目的是减少函数调用的开销。然而，虚函数的主要目的是实现运行时多态，它们在运行时通过虚函数表（vtable）来实现动态分派。这意味着编译器在编译时无法知道确切的虚函数实现，因此很难将虚函数内联。 &#x3D;&#x3D;静态函数能定义为虚函数吗？&#x3D;&#x3D; 静态函数不能定义为虚函数。原因在于静态函数和虚函数的特性是互斥的。 静态函数是属于类的，而不是属于类的某个对象的。它可以在没有创建类对象的情况下被调用。静态成员函数没有this指针，因为它们不与任何特定的类对象关联。所以，静态函数不能访问类的非静态成员。虚函数的目的是实现多态。虚函数允许派生类覆盖或重写基类中的虚函数。多态是通过虚函数表（vtable）实现的，每个具有虚函数的对象都有一个虚函数表指针。当我们通过基类指针或引用调用虚函数时，编译器会根据虚函数表动态地确定要调用的实际函数实现。因为静态函数不与任何类对象关联，所以它们不具备this指针和虚函数表指针。这意味着它们无法实现动态分派，也就不能实现虚函数的多态特性。所以，静态函数不能定义为虚函数。如果试图将静态函数定义为虚函数，编译器会报错，指出这是不允许的行为。 抽象基类 纯虚函数 通过在函数体的位置（即在声明语句的分号之前）书写 &#x3D;0 就可以将一个虚函数说明为纯虚函数，其中 &#x3D;0 只能出现在类内部的虚函数声明语句处； 不能在类的内部为一个 &#x3D;0 的函数提供函数体。 含有纯虚函数的类是抽象基类 抽象基类负责定义接口，而后续其他类可以覆盖该接口； 不能创建一个抽象基类的对象。 派生类构造函数只初始化它的直接基类 每个类各自控制其对象的初始化过程。 &#x3D;&#x3D;抽象基类为什么不能创建对象？&#x3D;&#x3D; 不完整性：抽象基类中的纯虚函数没有实现，这意味着抽象基类是一个不完整的类。创建一个不完整的类对象是没有意义的，因为它无法完成预期的操作。 设计目的：抽象基类通常表示一个抽象概念，它封装了一组共享的行为和属性，这些行为和属性可以在派生类中具体实现。因此，抽象基类的设计初衷就是让其他类继承和实现它，而不是直接创建对象。 防止误用：禁止创建抽象基类对象有助于确保开发者遵循面向对象设计原则，不会误用抽象基类。如果允许创建抽象基类对象，那么在调用纯虚函数时，将无法找到对应的实现，从而导致未定义行为。禁止创建抽象基类对象可以确保这种情况不会发生。 访问控制与继承 class和struct： 使用 class 关键字定义的派生类是私有继承，使用 struct 关键字定义的派生类是公有继承； struct 和 class 的唯一差别就是默认成员访问说明符以及默认派生访问说明符。 继承权限 派生类对基类成员的访问权限取决于两点：继承方式和基类成员在基类中的访问权限 public 继承： 当使用public继承时，基类的public成员在派生类中保持为public，基类的protected成员在派生类中保持为protected，基类的private成员在派生类中不可访问。这是继承的最常用形式，保持了基类的访问级别。 private 继承： 当使用private继承时，基类的public和protected成员在派生类中变为private。基类的private成员在派生类中不可访问。这种继承形式在实现细节上有所不同，因为派生类以一种更受限的方式继承了基类的成员。 protected 继承： 当使用protected继承时，基类的public和protected成员在派生类中变为protected，基类的private成员在派生类中不可访问。这种继承形式的用途较为有限，但它可以在某些特定情况下使用，例如当你希望派生类能访问基类的某些成员，但同时限制这些成员在派生类之外的访问。 继承中的类作用域 当存在继承关系时 派生类的作用域嵌套在其基类的作用域之内 派生类可以像使用自己的成员一样使用基类的成员，但基类无法通过对象、引用或指针调用派生类的成员。 名字冲突与继承 派生类的成员将隐藏同名的基类成员 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字 名字查找先于类型检查 若派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏（而非重载）该基类成员，即使派生类和基类成员的形参列表不一致。 虚函数必须有相同的形参列表，否则就不是覆盖（override）而是隐藏了。 构造函数与拷贝控制 基类通常应该定义一个虚析构函数，这样就能动态分配继承体系中的对象。 使用虚析构函数可以在通过基类指针或引用时动态绑定析构函数 若基类的析构函数不是虚函数，则delete指向派生类对象的基类指针将产生未定义的行为 虚析构函数将阻止合成移动操作 派生类中删除的拷贝控制与基类的关系 若基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类对应的成员将是被删除的，因为此时编译器不能使用基类成员来执行派生类对象的基类部分的构造、赋值或销毁操作； 派生类的拷贝控制成员 派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员；类似的，派生类赋值运算符也必须为基类部分的成员赋值； 默认情况下，基类默认构造函数初始化派生类对象的基类部分；若想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数：","categories":[{"name":"后端","slug":"后端","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C++总结","slug":"后端/C-总结","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/"}],"tags":[]}],"categories":[{"name":"后端","slug":"后端","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C++总结","slug":"后端/C-总结","permalink":"https://lyfu0814.github.io/categories/%E5%90%8E%E7%AB%AF/C-%E6%80%BB%E7%BB%93/"}],"tags":[]}